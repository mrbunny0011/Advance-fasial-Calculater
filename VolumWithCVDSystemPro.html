<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Volume With CVD System Pro</title>
  <style>
    /* Add this new style for the search container */
    .search-container {
      position: relative;
      margin-bottom: 10px;
    }
    #coinSearch {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #ced4da;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 14px;
      transition: all 0.3s;
    }
    #coinSearch:focus {
      outline: none;
      border-color: #80bdff;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    #coinSelect {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #ced4da;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    /* Rest of your existing styles... */
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background-color: #f5f7fa; 
      color: #343a40; 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
    }
    header { 
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); 
      padding: 15px 20px; 
      text-align: center; 
      font-size: 24px; 
      color: white;
      font-weight: 600;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      border-bottom: none;
    }
    .container { 
      display: flex; 
      flex-direction: row; 
      height: calc(100vh - 54px); 
    }
    .left-panel { 
      width: 280px; 
      background-color: #ffffff; 
      padding: 15px; 
      overflow-y: auto; 
      border-right: 1px solid #e0e0e0;
      box-shadow: 2px 0 10px rgba(0,0,0,0.05);
    }
    .right-panel { 
      flex: 1; 
      position: relative; 
      padding: 20px; 
      overflow: hidden; 
      background-color: #f8fafc;
    }
    select, button { 
      width: 100%; 
      padding: 12px; 
      margin-bottom: 12px; 
      background: #ffffff; 
      color: #495057; 
      border: 1px solid #ced4da; 
      border-radius: 8px; 
      font-size: 14px;
      transition: all 0.3s;
    }
    select:focus, button:focus {
      outline: none;
      border-color: #80bdff;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    .signal-box { 
      background: #ffffff; 
      padding: 15px; 
      border-radius: 12px; 
      margin-bottom: 15px; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.05); 
      border: 1px solid #e9ecef;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .signal-box:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.1);
    }
    .candle-labels { 
      position: absolute; 
      top: 20px; 
      left: 20px; 
      background: rgba(255,255,255,0.95); 
      padding: 12px; 
      border-radius: 12px; 
      z-index: 10; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
      border: 1px solid #e9ecef;
      font-size: 14px;
    }
    .label-green { color: #28a745; font-weight: 500; }
    .label-red { color: #dc3545; font-weight: 500; }
    .label-blue { color: #17a2b8; font-weight: 500; }
    canvas { 
      background-color: #ffffff; 
      width: 100%; 
      height: 100%; 
      border-radius: 12px; 
      display: block; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.05); 
      border: 1px solid #e9ecef;
    }
    .time-display { 
      position: absolute; 
      bottom: 20px; 
      left: 20px; 
      background: rgba(255,255,255,0.95); 
      padding: 8px 12px; 
      border-radius: 8px; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
      border: 1px solid #e9ecef;
      font-size: 14px;
      font-weight: 500;
    }
    .live-indicator { 
      position: absolute; 
      top: 20px; 
      right: 20px; 
      background: #dc3545; 
      color: white; 
      padding: 6px 12px; 
      border-radius: 20px; 
      animation: pulse 1s infinite; 
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    @keyframes pulse { 
      0% { opacity: 0.6; } 
      50% { opacity: 1; } 
      100% { opacity: 0.6; } 
    }
    .tooltip { 
      position: absolute; 
      background: rgba(255,255,255,0.98); 
      padding: 12px; 
      border-radius: 8px; 
      pointer-events: none; 
      z-index: 100; 
      display: none; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
      border: 1px solid #e9ecef;
      font-size: 13px;
      max-width: 250px;
    }
    .signal-strong-bullish { color: #218838; font-weight: bold; background-color: #e6f7ea; padding: 4px 8px; border-radius: 6px; }
    .signal-bullish { color: #28a745; font-weight: 500; background-color: #e8f5e9; padding: 4px 8px; border-radius: 6px; }
    .signal-neutral { color: #17a2b8; font-weight: 500; background-color: #e3f6fc; padding: 4px 8px; border-radius: 6px; }
    .signal-bearish { color: #dc3545; font-weight: 500; background-color: #fce8e8; padding: 4px 8px; border-radius: 6px; }
    .signal-strong-bearish { color: #c82333; font-weight: bold; background-color: #f8d7da; padding: 4px 8px; border-radius: 6px; }
    .history-toggle { 
      display: flex; 
      justify-content: space-between; 
      margin-bottom: 10px; 
    }
    .history-toggle button { 
      width: 48%; 
      padding: 10px; 
      font-size: 13px;
      border-radius: 6px;
    }
    .history-table { 
      width: 100%; 
      border-collapse: collapse; 
      margin-top: 10px; 
      font-size: 13px;
    }
    .history-table th, .history-table td { 
      padding: 8px; 
      text-align: left; 
      border-bottom: 1px solid #e9ecef; 
    }
    .history-table th { 
      background-color: #f8f9fa; 
      font-weight: 600;
      color: #495057;
    }
    .active-toggle { 
      background-color: #007bff !important; 
      color: white !important; 
      font-weight: 500;
    }
    .signal-rising { color: #218838; font-weight: bold; background-color: #e6f7ea; padding: 4px 8px; border-radius: 6px; }
    .signal-falling { color: #dc3545; font-weight: bold; background-color: #fce8e8; padding: 4px 8px; border-radius: 6px; }
    .signal-accumulation { color: #28a745; font-weight: bold; background-color: #e8f5e9; padding: 4px 8px; border-radius: 6px; }
    .signal-distribution { color: #dc3545; font-weight: bold; background-color: #fce8e8; padding: 4px 8px; border-radius: 6px; }
    .signal-bullish-divergence { color: #218838; font-weight: bold; background-color: #e6f7ea; padding: 4px 8px; border-radius: 6px; }
    .signal-bearish-divergence { color: #c82333; font-weight: bold; background-color: #f8d7da; padding: 4px 8px; border-radius: 6px; }
    .signal-ai-bullish { color: #218838; font-weight: bold; background-color: #e6f7ea; padding: 6px 8px; border-radius: 6px; border-left: 4px solid #28a745; }
    .signal-ai-bearish { color: #c82333; font-weight: bold; background-color: #f8d7da; padding: 6px 8px; border-radius: 6px; border-left: 4px solid #dc3545; }
    .signal-ai-neutral { color: #17a2b8; font-weight: bold; background-color: #e3f6fc; padding: 6px 8px; border-radius: 6px; border-left: 4px solid #17a2b8; }
    .signal-ai-confirmed { color: #218838; font-weight: bold; background-color: #d4edda; padding: 6px 8px; border-radius: 6px; border: 1px solid #28a745; }
    .signal-ai-warning { color: #ffc107; font-weight: bold; background-color: #fff3cd; padding: 6px 8px; border-radius: 6px; border: 1px solid #ffc107; }
    .signal-spike { color: #6f42c1; font-weight: bold; background-color: #e9e3ff; padding: 4px 8px; border-radius: 6px; }
    .signal-trap { color: #fd7e14; font-weight: bold; background-color: #ffe8d9; padding: 4px 8px; border-radius: 6px; }
    .signal-confirmed { color: #218838; font-weight: bold; background-color: #e6f7ea; padding: 4px 8px; border-radius: 6px; }
    .signal-imbalance { color: #6610f2; font-weight: bold; background-color: #e9e3ff; padding: 4px 8px; border-radius: 6px; }
    /* New styles for trend prediction features */
    .signal-trend-alert {
      font-weight: bold;
      color: #fd7e14;
      background-color: #fff3e0;
      padding: 8px;
      border-radius: 8px;
      border-left: 4px solid #fd7e14;
    }
    .signal-zone-memory {
      color: #17a2b8;
      font-weight: bold;
      background-color: #e3f6fc;
      padding: 8px;
      border-radius: 8px;
      border-left: 4px solid #17a2b8;
    }
    .signal-trap-detect {
      color: #fd7e14;
      font-weight: bold;
      background-color: #fff3e0;
      padding: 8px;
      border-radius: 8px;
      border-left: 4px solid #fd7e14;
    }
    /* Whale order styles */
    .whale-display {
      font-weight: bold;
      margin-top: 10px;
      font-size: 14px;
    }
    .whale-buy {
      color: #28a745;
      background-color: #e8f5e9;
      padding: 8px;
      border-radius: 8px;
      margin-bottom: 5px;
    }
    .whale-sell {
      color: #dc3545;
      background-color: #fce8e8;
      padding: 8px;
      border-radius: 8px;
      margin-bottom: 5px;
    }
    .reversal-level {
      white-space: pre-line;
      color: #fd7e14;
      margin-top: 5px;
      font-weight: bold;
      background-color: #fff3e0;
      padding: 8px;
      border-radius: 8px;
      font-size: 14px;
    }

    /* Button styling */
    button {
      background-color: #007bff;
      color: white;
      border: none;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s;
    }
    button:hover {
      background-color: #0069d9;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #toggleLive {
      background-color: #dc3545;
    }
    #toggleLive:hover {
      background-color: #c82333;
    }

    /* ========== RESPONSIVE DESIGN ADDITIONS ========== */
    @media (max-width: 1200px) {
      .container {
        flex-direction: column;
        height: auto;
      }
      .left-panel {
        width: 100%;
        height: auto;
        max-height: 50vh;
        overflow-y: auto;
        border-right: none;
        border-bottom: 1px solid #e9ecef;
      }
      .right-panel {
        height: 60vh;
      }
      .signal-box {
        padding: 12px;
        margin-bottom: 12px;
      }
      .candle-labels {
        font-size: 12px;
        padding: 10px;
      }
    }

    @media (max-width: 768px) {
      header {
        font-size: 18px;
        padding: 12px 10px;
      }
      .left-panel, .right-panel {
        padding: 12px;
      }
      select, button {
        padding: 10px;
        font-size: 14px;
      }
      .signal-box {
        padding: 10px;
      }
      .history-table th, .history-table td {
        padding: 6px;
        font-size: 12px;
      }
      .candle-labels {
        position: relative;
        top: auto;
        left: auto;
        margin-bottom: 12px;
        width: 100%;
        box-sizing: border-box;
      }
      .time-display {
        position: relative;
        bottom: auto;
        left: auto;
        margin-top: 12px;
      }
      .live-indicator {
        position: relative;
        top: auto;
        right: auto;
        display: inline-block;
        margin-bottom: 12px;
      }
    }

    @media (max-width: 480px) {
      header {
        font-size: 16px;
      }
      .container {
        flex-direction: column;
      }
      .left-panel {
        max-height: 40vh;
      }
      .right-panel {
        height: 50vh;
      }
      select, button {
        padding: 10px;
        font-size: 12px;
      }
      .history-toggle button {
        padding: 8px;
        font-size: 12px;
      }
      .signal-box {
        font-size: 14px;
      }
      .history-table {
        font-size: 11px;
      }
    }

    /* Mobile menu toggle */
    .mobile-menu-toggle {
      display: none;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: white;
      border: none;
      padding: 12px;
      margin-bottom: 12px;
      width: 100%;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s;
    }
    .mobile-menu-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    @media (max-width: 768px) {
      .mobile-menu-toggle {
        display: block;
      }
      .left-panel {
        display: none;
      }
      .left-panel.active {
        display: block;
      }
    }
    /* ========== END OF RESPONSIVE DESIGN ========== */
  </style>
</head>
<body>
  <header>Volume With CVD System Pro</header>
  <div class="container">
    <button class="mobile-menu-toggle" id="mobileMenuToggle">☰ Show/Hide Controls</button>
    <div class="left-panel" id="leftPanel">
      <!-- Add search input above the coin select -->
      <div class="search-container">
        <input type="text" id="coinSearch" placeholder="Search coin..." />
        <select id="coinSelect"></select>
      </div>
      
      <select id="timeframeSelect">
        <option value="1m">1 Minute</option>
        <option value="3m">3 Minutes</option>
        <option value="5m">5 Minutes</option>
        <option value="15m">15 Minutes</option>
        <option value="30m">30 Minutes</option>
        <option value="1h">1 Hour</option>
        <option value="2h">2 Hours</option>
        <option value="4h">4 Hours</option>
        <option value="6h">6 Hours</option>
        <option value="8h">8 Hours</option>
        <option value="12h">12 Hours</option>
        <option value="1d">1 Day</option>
        <option value="3d">3 Days</option>
        <option value="1w">1 Week</option>
        <option value="1M">1 Month</option>
      </select>
      <button id="toggleLive">Pause Live Data</button>

      <div class="signal-box" id="signalOutput">
        <strong>Current Signal:</strong>
        <div id="signalText">Loading...</div>
        <div id="signalStrength"></div>
      </div>

      <div class="signal-box">
        <strong>Current Candle:</strong><br />
        Open: <span id="currOpen">--</span><br />
        High: <span id="currHigh">--</span><br />
        Low: <span id="currLow">--</span><br />
        Close: <span id="currClose">--</span><br />
        Buy Vol: <span id="currBuy">--</span><br />
        Sell Vol: <span id="currSell">--</span><br />
        CVD: <span id="currCVD">--</span>
      </div>

      <div class="signal-box">
        <strong>Previous Candle:</strong><br />
        Open: <span id="prevOpen">--</span><br />
        High: <span id="prevHigh">--</span><br />
        Low: <span id="prevLow">--</span><br />
        Close: <span id="prevClose">--</span><br />
        Buy Vol: <span id="prevBuy">--</span><br />
        Sell Vol: <span id="prevSell">--</span><br />
        CVD: <span id="prevCVD">--</span>
      </div>

      <!-- Whale Order Detector -->
      <div class="signal-box">
        <strong>Whale Order Detector:</strong>
        <div id="whaleBuyDisplay" class="whale-buy">🐋 Buy: --</div>
        <div id="whaleSellDisplay" class="whale-sell">🐋 Sell: --</div>
        <div id="reversalLevelDisplay" class="reversal-level">⚠️ No Reversal Zone Detected</div>
      </div>

      <!-- 🔮 ADVANCED FEATURES -->
      <div class="signal-box" id="trendChangeBox">
        <strong>Smart Trend Prediction:</strong>
        <div id="trendChangeText">--</div>
      </div>

      <div class="signal-box" id="smartTrapSignal">
        <strong>Smart Trap Detection:</strong>
        <div id="smartTrapText">--</div>
      </div>

      <div class="signal-box" id="liquidityZoneMemory">
        <strong>Liquidity Zone Memory:</strong>
        <div id="zoneMemoryText">--</div>
      </div>

      <div class="signal-box">
        <strong>Confirmed Trend (Last 5 Closed):</strong>
        <div id="cvdSlopeClosed">Calculating...</div>
      </div>

      <div class="signal-box">
        <strong>Live Trend (With Current Candle):</strong>
        <div id="cvdSlopeCurrent">Calculating...</div>
      </div>

      <div class="signal-box">
        <strong>AI Projection (Based on Both):</strong>
        <div id="aiFinalSignal">Processing...</div>
      </div>

      <div class="signal-box">
        <strong>CVD Acceleration:</strong>
        <div id="cvdAccelerationSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Fakeout Trap Detector:</strong>
        <div id="fakeoutSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Whale Wall (Order Book):</strong>
        <div id="whaleWallSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Volume Spike:</strong>
        <div id="volumeSpikeSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Smart Divergence:</strong>
        <div id="smartDivergenceSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Wick Trap:</strong>
        <div id="wickTrapSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>OBV + CVD Confirmation:</strong>
        <div id="obvCvdSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Order Book Imbalance:</strong>
        <div id="orderBookSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Zone Status:</strong>
        <div id="zoneStatus">Analyzing...</div>
      </div>

      <div class="signal-box">
        <strong>Divergence:</strong>
        <div id="divergenceSignal">--</div>
      </div>

      <div class="signal-box">
        <strong>Buy/Sell Imbalance:</strong>
        <div style="display:flex; align-items:center;">
          <div style="width:70%; background:#e9ecef; border-radius:8px; overflow:hidden; margin-right:10px; height: 24px;">
            <div id="buyBar" style="height:100%; background:#28a745; width:50%"></div>
          </div>
          <span id="volDeltaLabel" style="font-size:14px;">50% / 50%</span>
        </div>
      </div>
      <!-- END OF ADVANCED FEATURES -->

      <div class="signal-box">
        <div class="history-toggle">
          <button id="toggle5" class="active-toggle">Last 5 Candles</button>
          <button id="toggle10">Last 10 Candles</button>
        </div>
        <div class="history-toggle">
          <button id="toggleWithCurrent" class="active-toggle">With Current</button>
          <button id="toggleWithoutCurrent">Without Current</button>
        </div>
        <div id="historyContainer">
          <table class="history-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Buy</th>
                <th>Sell</th>
                <th>CVD</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <!-- Filled dynamically -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="right-panel">
      <div class="live-indicator">LIVE</div>
      <canvas id="chartCanvas"></canvas>
      <div class="candle-labels">
        <div>📊 Candle Labels (Live):</div>
        <div>Open: <span id="chartOpen">--</span></div>
        <div>High: <span id="chartHigh">--</span></div>
        <div>Low: <span id="chartLow">--</span></div>
        <div>Close: <span id="chartClose">--</span></div>
        <div>Buy Vol: <span class="label-green" id="chartBuyVol">--</span></div>
        <div>Sell Vol: <span class="label-red" id="chartSellVol">--</span></div>
        <div>CVD: <span class="label-blue" id="chartCVD">--</span></div>
        <div>Signal: <span id="chartSignal">--</span></div>
      </div>
      <div class="time-display" id="timeDisplay"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>

  <!-- The rest of your JavaScript remains exactly the same -->
  <script>
    // Global variables
    const coinSelect = document.getElementById('coinSelect');
    const coinSearch = document.getElementById('coinSearch');
    const timeframeSelect = document.getElementById('timeframeSelect');
    const toggleLiveBtn = document.getElementById('toggleLive');
    const chartCanvas = document.getElementById('chartCanvas');
    const ctx = chartCanvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const toggle5Btn = document.getElementById('toggle5');
    const toggle10Btn = document.getElementById('toggle10');
    const toggleWithCurrentBtn = document.getElementById('toggleWithCurrent');
    const toggleWithoutCurrentBtn = document.getElementById('toggleWithoutCurrent');
    const historyBody = document.getElementById('historyBody');
    const mobileMenuToggle = document.getElementById('mobileMenuToggle');
    const leftPanel = document.getElementById('leftPanel');
    
    let candles = [];
    let liveDataEnabled = true;
    let socket = null;
    let domSocket = null;
    let currentSymbol = 'BTCUSDT';
    let currentInterval = '5m';
    let viewStart = 0;
    let viewEnd = 100;
    let isDragging = false;
    let dragStartX = 0;
    let initialViewStart = 0;
    let initialViewEnd = 0;
    let candleWidth = 10;
    let lastUpdateTime = 0;
    let lastPrice = 0;
    let cumulativeCVD = 0;
    let historyCount = 5;
    let includeCurrent = true;
    let allCoins = []; // Store all coins for search functionality
    
    // Whale order tracking
    let whaleBuyOrder = { price: 0, quantity: 0 };
    let whaleSellOrder = { price: 0, quantity: 0 };
    let reversalBuyLevel = null;
    let reversalSellLevel = null;
    const whaleThreshold = 10000; // Only show if quantity > 10,000
    const reversalThreshold = 500000; // USD value for potential reversal
    
    // Initialize chart dimensions
    function initChartDimensions() {
      chartCanvas.width = chartCanvas.offsetWidth;
      chartCanvas.height = chartCanvas.offsetHeight;
      candleWidth = Math.max(5, Math.min(20, chartCanvas.width / (viewEnd - viewStart)));
    }
    
    // Format volume numbers
    function formatVolume(num) {
      if (num >= 1000000000000) return (num / 1000000000000).toFixed(2) + 'T';
      if (num >= 1000000000) return (num / 1000000000).toFixed(2) + 'B';
      if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
      if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
      return num.toFixed(2);
    }
    
    // Format price
    function formatPrice(price) {
      return parseFloat(price).toFixed(6);
    }
    
    // Format time
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.getHours().toString().padStart(2, '0') + ':' + 
             date.getMinutes().toString().padStart(2, '0') + ':' +
             date.getSeconds().toString().padStart(2, '0');
    }
    
    // Calculate signal strength
    function getSignalStrength(cvd) {
      if (cvd > 0) {
        if (cvd > cumulativeCVD * 0.3) return { text: 'STRONG BULLISH', class: 'signal-strong-bullish' };
        return { text: 'Bullish', class: 'signal-bullish' };
      } else {
        if (cvd < cumulativeCVD * -0.3) return { text: 'STRONG BEARISH', class: 'signal-strong-bearish' };
        return { text: 'Bearish', class: 'signal-bearish' };
      }
    }
    
    // Update history table
    function updateHistoryTable() {
      historyBody.innerHTML = '';
      
      const startIndex = includeCurrent ? candles.length - historyCount : candles.length - historyCount - 1;
      const endIndex = includeCurrent ? candles.length : candles.length - 1;
      
      for (let i = Math.max(0, startIndex); i < endIndex; i++) {
        const candle = candles[i];
        const row = document.createElement('tr');
        
        row.innerHTML = `
          <td>${formatTime(candle.time)}</td>
          <td>${formatVolume(candle.buyVolume)}</td>
          <td>${formatVolume(candle.sellVolume)}</td>
          <td>${formatVolume(candle.buyVolume - candle.sellVolume)}</td>
        `;
        
        historyBody.appendChild(row);
      }
    }
    
    // Fetch coins list
    async function fetchCoins() {
      try {
        const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        const data = await res.json();
        const symbols = data.symbols.filter(s => s.symbol.endsWith('USDT') && s.contractType === 'PERPETUAL');
        
        // Store all coins for search functionality
        allCoins = symbols.map(s => s.symbol);
        
        // Populate the select dropdown
        populateCoinSelect(allCoins);
        
        currentSymbol = coinSelect.value;
        loadInitialKlines();
      } catch (err) {
        console.error('Error fetching coins:', err);
      }
    }
    
    // Populate coin select with optional filter
    function populateCoinSelect(coins, filter = '') {
      coinSelect.innerHTML = ''; // Clear existing options
      
      const filteredCoins = filter 
        ? coins.filter(coin => coin.toLowerCase().includes(filter.toLowerCase()))
        : coins;
        
      filteredCoins.forEach((symbol) => {
        const option = document.createElement('option');
        option.value = symbol;
        option.innerText = symbol;
        if (symbol === 'BTCUSDT') option.selected = true;
        coinSelect.appendChild(option);
      });
    }
    
    // Load initial klines data
    async function loadInitialKlines() {
      currentSymbol = coinSelect.value || 'BTCUSDT';
      currentInterval = timeframeSelect.value || '5m';
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${currentSymbol}&interval=${currentInterval}&limit=500`;
      
      try {
        const res = await fetch(url);
        const data = await res.json();
        candles = data.map(c => ({
          time: c[0],
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5]),
          quoteVolume: parseFloat(c[7]),
          trades: c[8],
          buyVolume: parseFloat(c[9]),  // Using taker buy volume as buy volume
          sellVolume: parseFloat(c[5]) - parseFloat(c[9]),  // Total volume - buy volume
          isClosed: true  // All historical candles are closed
        }));
        
        // Calculate initial cumulative CVD
        cumulativeCVD = candles.reduce((sum, candle) => sum + (candle.buyVolume - candle.sellVolume), 0);
        
        viewStart = Math.max(0, candles.length - 100);
        viewEnd = candles.length;
        initChartDimensions();
        drawChart();
        setupWebSocket();
        setupDOMWebSocket();
        updateLiveData();
        updateHistoryTable();
        updateAdvancedSignals();
        updateDualCVDSlope(); // Initialize dual slope analysis
        updateAdvancedFeatures(); // Initialize advanced features
      } catch (err) {
        console.error('Error loading klines:', err);
      }
    }
    
    // Setup WebSocket for live data
    function setupWebSocket() {
      if (socket) {
        socket.close();
      }
      
      const streamName = `${currentSymbol.toLowerCase()}@kline_${currentInterval}`;
      socket = new WebSocket(`wss://fstream.binance.com/ws/${streamName}`);
      
      socket.onopen = () => {
        console.log('WebSocket connected');
      };
      
      socket.onmessage = (event) => {
        if (!liveDataEnabled) return;
        
        const message = JSON.parse(event.data);
        if (message.k) {
          const kline = message.k;
          const newCandle = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v),
            quoteVolume: parseFloat(kline.q),
            trades: kline.n,
            buyVolume: parseFloat(kline.V),  // Taker buy volume
            sellVolume: parseFloat(kline.v) - parseFloat(kline.V),  // Total volume - buy volume
            isClosed: kline.x
          };
          
          // Update or add candle
          const lastCandle = candles[candles.length - 1];
          if (lastCandle && lastCandle.time === newCandle.time) {
            // Update existing candle
            Object.assign(lastCandle, newCandle);
          } else if (newCandle.isClosed) {
            // Add new candle
            candles.push(newCandle);
            // Update cumulative CVD
            cumulativeCVD += (newCandle.buyVolume - newCandle.sellVolume);
            if (candles.length > 500) {
              const removedCandle = candles.shift(); // Keep only 500 candles
              cumulativeCVD -= (removedCandle.buyVolume - removedCandle.sellVolume);
            }
          }
          
          lastPrice = newCandle.close;
          
          // Update view if at the end
          if (viewEnd >= candles.length - 5) {
            viewStart = Math.max(0, candles.length - (viewEnd - viewStart));
            viewEnd = candles.length;
          }
          
          drawChart();
          updateLiveData();
          updateHistoryTable();
          updateAdvancedSignals();
          updateDualCVDSlope(); // Update dual slope analysis with new data
          updateAdvancedFeatures(); // Update advanced features
        }
      };
      
      socket.onclose = () => {
        console.log('WebSocket disconnected');
        if (liveDataEnabled) {
          setTimeout(setupWebSocket, 5000); // Reconnect after 5 seconds
        }
      };
    }

    // Setup DOM WebSocket for order book data
    function setupDOMWebSocket() {
      if (domSocket) {
        domSocket.close();
      }
      
      const streamName = `${currentSymbol.toLowerCase()}@depth10@100ms`;
      domSocket = new WebSocket(`wss://fstream.binance.com/ws/${streamName}`);
      
      domSocket.onopen = () => {
        console.log('DOM WebSocket connected');
      };
      
      domSocket.onmessage = (event) => {
        if (!liveDataEnabled) return;
        
        const data = JSON.parse(event.data);
        const bids = data.bids.map(b => parseFloat(b[1]));
        const asks = data.asks.map(a => parseFloat(a[1]));
        const buyDepth = bids.reduce((a, b) => a + b, 0);
        const sellDepth = asks.reduce((a, b) => a + b, 0);

        const signal = detectWhaleWalls(buyDepth, sellDepth);
        document.getElementById("whaleWallSignal").innerText = signal.text;
        document.getElementById("whaleWallSignal").className = signal.class;
        
        // Process whale orders and reversal levels
        processDepthData({ bids: data.bids, asks: data.asks });
        
        // Update order book pressure with real depth values
        detectOrderBookPressure(buyDepth, sellDepth);
      };
      
      domSocket.onclose = () => {
        console.log('DOM WebSocket disconnected');
        if (liveDataEnabled) {
          setTimeout(setupDOMWebSocket, 5000); // Reconnect after 5 seconds
        }
      };
    }
    
    // Process depth data for whale orders and reversal levels
    function processDepthData(data) {
      const buyLevels = data.bids.map(([price, qty]) => ({ price: parseFloat(price), quantity: parseFloat(qty) }));
      const sellLevels = data.asks.map(([price, qty]) => ({ price: parseFloat(price), quantity: parseFloat(qty) }));

      // Filter whales only
      const bigBuys = buyLevels.filter(level => level.quantity > whaleThreshold);
      const bigSells = sellLevels.filter(level => level.quantity > whaleThreshold);

      if (bigBuys.length > 0) whaleBuyOrder = bigBuys.sort((a, b) => b.quantity - a.quantity)[0];
      else whaleBuyOrder = { price: 0, quantity: 0 };

      if (bigSells.length > 0) whaleSellOrder = bigSells.sort((a, b) => b.quantity - a.quantity)[0];
      else whaleSellOrder = { price: 0, quantity: 0 };

      // Detect reversal level (USD value of big order)
      const maxBuy = bigBuys.find(b => b.price * b.quantity >= reversalThreshold);
      const maxSell = bigSells.find(s => s.price * s.quantity >= reversalThreshold);
      reversalBuyLevel = maxBuy ? maxBuy : null;
      reversalSellLevel = maxSell ? maxSell : null;

      updateWhaleOrderDisplay();
    }

    // Update whale order display
    function updateWhaleOrderDisplay() {
      const buyEl = document.getElementById("whaleBuyDisplay");
      const sellEl = document.getElementById("whaleSellDisplay");
      const reversalEl = document.getElementById("reversalLevelDisplay");

      if (buyEl) {
        const usdBuy = whaleBuyOrder.price * whaleBuyOrder.quantity;
        buyEl.textContent = whaleBuyOrder.quantity > 0
          ? `🐋 Buy: ${whaleBuyOrder.price.toFixed(2)} (${formatLargeNumber(whaleBuyOrder.quantity)}) ≈ $${formatLargeNumber(usdBuy)}`
          : "🐋 Buy: --";
      }
      if (sellEl) {
        const usdSell = whaleSellOrder.price * whaleSellOrder.quantity;
        sellEl.textContent = whaleSellOrder.quantity > 0
          ? `🐋 Sell: ${whaleSellOrder.price.toFixed(2)} (${formatLargeNumber(whaleSellOrder.quantity)}) ≈ $${formatLargeNumber(usdSell)}`
          : "🐋 Sell: --";
      }

      if (reversalEl) {
        if (reversalBuyLevel || reversalSellLevel) {
          let msg = "";
          if (reversalBuyLevel) {
            msg += `⚠️ Reversal Buy Zone: ${reversalBuyLevel.price.toFixed(2)} ($${formatLargeNumber(reversalBuyLevel.price * reversalBuyLevel.quantity)}\n`;
          }
          if (reversalSellLevel) {
            msg += `⚠️ Reversal Sell Zone: ${reversalSellLevel.price.toFixed(2)} ($${formatLargeNumber(reversalSellLevel.price * reversalSellLevel.quantity)})`;
          }
          reversalEl.textContent = msg;
        } else {
          reversalEl.textContent = "⚠️ No Reversal Zone Detected";
        }
      }
    }

    // Format large numbers for whale display
    function formatLargeNumber(num) {
      if (num >= 1e12) return (num / 1e12).toFixed(2) + "T";
      if (num >= 1e9) return (num / 1e9).toFixed(2) + "B";
      if (num >= 1e6) return (num / 1e6).toFixed(2) + "M";
      if (num >= 1e3) return (num / 1e3).toFixed(2) + "K";
      return num.toFixed(2);
    }
    
    // Update live data displays
    function updateLiveData() {
      if (candles.length < 2) return;
      
      const prev = candles[candles.length - 2];
      const curr = candles[candles.length - 1];
      
      // Calculate proper CVD (Buy Volume - Sell Volume)
      const cvd = curr.buyVolume - curr.sellVolume;
      
      // Format time
      const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit' };
      const currentTime = new Date(curr.time).toLocaleTimeString([], timeOptions);
      document.getElementById('timeDisplay').textContent = currentTime;
      
      // Update previous candle data
      document.getElementById('prevOpen').innerText = formatPrice(prev.open);
      document.getElementById('prevHigh').innerText = formatPrice(prev.high);
      document.getElementById('prevLow').innerText = formatPrice(prev.low);
      document.getElementById('prevClose').innerText = formatPrice(prev.close);
      document.getElementById('prevBuy').innerText = formatVolume(prev.buyVolume);
      document.getElementById('prevSell').innerText = formatVolume(prev.sellVolume);
      document.getElementById('prevCVD').innerText = formatVolume(prev.buyVolume - prev.sellVolume);
      
      // Update current candle data
      document.getElementById('currOpen').innerText = formatPrice(curr.open);
      document.getElementById('currHigh').innerText = formatPrice(curr.high);
      document.getElementById('currLow').innerText = formatPrice(curr.low);
      document.getElementById('currClose').innerText = formatPrice(curr.close);
      document.getElementById('currBuy').innerText = formatVolume(curr.buyVolume);
      document.getElementById('currSell').innerText = formatVolume(curr.sellVolume);
      document.getElementById('currCVD').innerText = formatVolume(cvd);
      
      // Update chart labels
      document.getElementById('chartOpen').innerText = formatPrice(curr.open);
      document.getElementById('chartHigh').innerText = formatPrice(curr.high);
      document.getElementById('chartLow').innerText = formatPrice(curr.low);
      document.getElementById('chartClose').innerText = formatPrice(curr.close);
      document.getElementById('chartBuyVol').innerText = formatVolume(curr.buyVolume);
      document.getElementById('chartSellVol').innerText = formatVolume(curr.sellVolume);
      document.getElementById('chartCVD').innerText = formatVolume(cvd);
      
      // Get signal strength
      const signal = getSignalStrength(cvd);
      
      // Set signal text and color
      const signalText = cvd > 0 ? 
        `✅ Bullish (${signal.text})` : 
        `🔻 Bearish (${signal.text})`;
      
      document.getElementById('chartSignal').innerText = signal.text;
      document.getElementById('chartSignal').className = signal.class;
      document.getElementById('signalText').innerText = signalText;
      document.getElementById('signalText').className = signal.class;
      document.getElementById('signalOutput').style.border = `1px solid ${signal.class.replace('signal-', '#')}`;
      document.getElementById('signalStrength').innerText = `CVD: ${formatVolume(cvd)}`;
      document.getElementById('signalStrength').className = signal.class;
    }
    
    // Draw the chart
    function drawChart() {
      if (candles.length === 0) return;
      
      const visibleCandles = candles.slice(viewStart, viewEnd);
      if (visibleCandles.length === 0) return;
      
      ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
      
      // Draw background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);
      
      // Calculate price range
      const maxPrice = Math.max(...visibleCandles.map(c => c.high));
      const minPrice = Math.min(...visibleCandles.map(c => c.low));
      const priceRange = maxPrice - minPrice;
      const scaleY = chartCanvas.height / priceRange;
      
      // Draw grid lines
      ctx.strokeStyle = 'Black';
      ctx.lineWidth = 0.5;
      ctx.font = '10px Arial';
      ctx.fillStyle = 'Black';
      
      // Horizontal grid lines and price labels
      for (let i = 0; i <= 10; i++) {
        const price = minPrice + (priceRange * (1 - i/10));
        const y = (price - minPrice) * scaleY;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(chartCanvas.width, y);
        ctx.stroke();
        
        ctx.fillText(formatPrice(price), 5, y + 12);
      }
      
      // Draw candles
      visibleCandles.forEach((candle, i) => {
        const x = i * candleWidth;
        const openY = (maxPrice - candle.open) * scaleY;
        const closeY = (maxPrice - candle.close) * scaleY;
        const highY = (maxPrice - candle.high) * scaleY;
        const lowY = (maxPrice - candle.low) * scaleY;
        
        // Draw wick
        ctx.strokeStyle = candle.close >= candle.open ? '#28a745' : '#dc3545';
        ctx.beginPath();
        ctx.moveTo(x + candleWidth/2, highY);
        ctx.lineTo(x + candleWidth/2, lowY);
        ctx.stroke();
        
        // Draw candle body
        ctx.fillStyle = candle.close >= candle.open ? '#28a745' : '#dc3545';
        const bodyHeight = Math.abs(closeY - openY);
        const bodyY = Math.min(openY, closeY);
        ctx.fillRect(x + candleWidth*0.15, bodyY, candleWidth*0.7, bodyHeight || 1);
        
        // Draw time labels every 10 candles
        if (i % 10 === 0) {
          const date = new Date(candle.time);
          const timeStr = date.getHours() + ':' + date.getMinutes().toString().padStart(2, '0');
          ctx.fillText(timeStr, x, chartCanvas.height - 5);
        }
      });
      
      // Draw current price line
      const currentPrice = visibleCandles[visibleCandles.length - 1].close;
      const currentY = (maxPrice - currentPrice) * scaleY;
      ctx.strokeStyle = '#ffc107';
      ctx.setLineDash([5, 3]);
      ctx.beginPath();
      ctx.moveTo(0, currentY);
      ctx.lineTo(chartCanvas.width, currentY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'Black';
      ctx.font = 'bold 16px Black'
      ctx.fillText(formatPrice(currentPrice), chartCanvas.width - 50, currentY + 12);
    }
    
    // Handle mouse events for chart interaction
    function setupChartInteractions() {
      let isDragging = false;
      let lastX = 0;
      let initialViewStart = 0;
      let initialViewEnd = 0;
      
      chartCanvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        initialViewStart = viewStart;
        initialViewEnd = viewEnd;
        chartCanvas.style.cursor = 'grabbing';
      });
      
      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const dx = e.clientX - lastX;
        const candleDiff = Math.round(dx / candleWidth);
        
        if (candleDiff !== 0) {
          viewStart = Math.max(0, initialViewStart - candleDiff);
          viewEnd = Math.min(candles.length, initialViewEnd - candleDiff);
          
          // Ensure we maintain the same number of visible candles
          if (viewEnd - viewStart !== initialViewEnd - initialViewStart) {
            if (viewStart === 0) {
              viewEnd = initialViewEnd - initialViewStart;
            } else {
              viewStart = viewEnd - (initialViewEnd - initialViewStart);
            }
          }
          
          drawChart();
        }
      });
      
      window.addEventListener('mouseup', () => {
        isDragging = false;
        chartCanvas.style.cursor = 'default';
      });
      
      chartCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        // Zoom based on wheel direction
        const zoomFactor = e.deltaY > 0 ? 0.8 : 1.2;
        const centerIndex = viewStart + (viewEnd - viewStart) / 2;
        const newViewRange = Math.max(10, Math.min(500, (viewEnd - viewStart) * zoomFactor));
        
        viewStart = Math.max(0, Math.floor(centerIndex - newViewRange / 2));
        viewEnd = Math.min(candles.length, Math.floor(centerIndex + newViewRange / 2));
        
        // Adjust candle width and redraw
        candleWidth = Math.max(2, Math.min(30, chartCanvas.width / (viewEnd - viewStart)));
        drawChart();
      });
      
      // Tooltip for candle details
      chartCanvas.addEventListener('mousemove', (e) => {
        if (isDragging) return;
        
        const rect = chartCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const candleIndex = viewStart + Math.floor(x / candleWidth);
        
        if (candleIndex >= viewStart && candleIndex < viewEnd && candleIndex < candles.length) {
          const candle = candles[candleIndex];
          const date = new Date(candle.time);
          const timeStr = date.toLocaleString();
          
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 2) + 'px';
          tooltip.style.top = (e.clientY + 2) + 'px';
          
          tooltip.innerHTML = `
            <div><strong>${timeStr}</strong></div>
            <div>Open: ${formatPrice(candle.open)}</div>
            <div>High: ${formatPrice(candle.high)}</div>
            <div>Low: ${formatPrice(candle.low)}</div>
            <div>Close: ${formatPrice(candle.close)}</div>
            <div>Volume: ${formatVolume(candle.volume)}</div>
            <div>Buy Vol: ${formatVolume(candle.buyVolume)}</div>
            <div>Sell Vol: ${formatVolume(candle.sellVolume)}</div>
            <div>CVD: ${formatVolume(candle.buyVolume - candle.sellVolume)}</div>
            <div>Trades: ${candle.trades}</div>
          `;
        } else {
          tooltip.style.display = 'none';
        }
      });
      
      chartCanvas.addEventListener('mouseout', () => {
        tooltip.style.display = 'none';
      });
    }
    
    // Update advanced signals
    function updateAdvancedSignals() {
      if (candles.length < 6) return;

      const last5 = candles.slice(-5);
      const cvds = last5.map(c => c.buyVolume - c.sellVolume);
      const avgCVD = cvds.reduce((a, b) => a + b, 0) / cvds.length;
      const slope = ((cvds[4] - cvds[0]) / Math.abs(cvds[0] || 1)) * 100;

      // Price Slope for Divergence Detection
      const priceSlope = ((last5[4].close - last5[0].close) / Math.abs(last5[0].close || 1)) * 100;

      // Divergence Detection
      const divergenceElement = document.getElementById("divergenceSignal");
      let divergence = "--";
      if (slope > 5 && priceSlope < -0.5) {
        divergence = "📈 Bullish Divergence";
        divergenceElement.className = 'signal-bullish-divergence';
      } else if (slope < -5 && priceSlope > 0.5) {
        divergence = "📉 Bearish Divergence";
        divergenceElement.className = 'signal-bearish-divergence';
      } else {
        divergenceElement.className = '';
      }
      divergenceElement.innerText = divergence;

      // Accumulation/Distribution Zone
      const zoneStatusElement = document.getElementById("zoneStatus");
      const last = candles[candles.length - 1];
      if (slope > 0 && last.close < last.open) {
        zoneStatusElement.innerText = "📥 Accumulation Zone";
        zoneStatusElement.className = 'signal-accumulation';
      } else if (slope < 0 && last.close > last.open) {
        zoneStatusElement.innerText = "📤 Distribution Zone";
        zoneStatusElement.className = 'signal-distribution';
      } else {
        zoneStatusElement.innerText = "Neutral";
        zoneStatusElement.className = '';
      }

      // Volume Delta Heatmap
      const total = last.buyVolume + last.sellVolume;
      const buyPerc = (last.buyVolume / total) * 100;
      document.getElementById("buyBar").style.width = `${buyPerc}%`;
      document.getElementById("volDeltaLabel").innerText = `${buyPerc.toFixed(1)}% / ${(100 - buyPerc).toFixed(1)}%`;
    }

    // Dual CVD Slope Analysis (Closed vs Current)
    function updateDualCVDSlope() {
      let slopeClosed = 0;
      let slopeCurrent = 0;
      let validClosed = false;
      let validCurrent = false;

      // --- CLOSED ONLY SIGNAL ---
      const closedCandles = candles.filter(c => c.isClosed);
      if (closedCandles.length >= 5) {
        const last5Closed = closedCandles.slice(-5);
        const cvdsClosed = last5Closed.map(c => c.buyVolume - c.sellVolume);
        slopeClosed = ((cvdsClosed[4] - cvdsClosed[0]) / Math.abs(cvdsClosed[0] || 1)) * 100;
        const elClosed = document.getElementById("cvdSlopeClosed");
        elClosed.innerText = slopeClosed > 0
          ? `🔼 Rising (${slopeClosed.toFixed(2)}%)`
          : `🔽 Falling (${slopeClosed.toFixed(2)}%)`;
        elClosed.className = slopeClosed > 0 ? 'signal-rising' : 'signal-falling';
        validClosed = true;
      }

      // --- WITH CURRENT SIGNAL ---
      if (candles.length >= 5) {
        const last5All = candles.slice(-5);
        const cvdsAll = last5All.map(c => c.buyVolume - c.sellVolume);
        slopeCurrent = ((cvdsAll[4] - cvdsAll[0]) / Math.abs(cvdsAll[0] || 1)) * 100;
        const elCurrent = document.getElementById("cvdSlopeCurrent");
        elCurrent.innerText = slopeCurrent > 0
          ? `🔼 Rising (${slopeCurrent.toFixed(2)}%)`
          : `🔽 Falling (${slopeCurrent.toFixed(2)}%)`;
        elCurrent.className = slopeCurrent > 0 ? 'signal-rising' : 'signal-falling';
        validCurrent = true;
      }

      // --- AI Projection Combining Both Slopes ---
      const finalAI = document.getElementById("aiFinalSignal");
      if (validClosed && validCurrent) {
        let finalText = "Neutral";
        let finalClass = "signal-ai-neutral";

        if (slopeClosed > 5 && slopeCurrent > 5) {
          finalText = "🚀 Strong Bullish Match";
          finalClass = "signal-ai-confirmed";
        } else if (slopeClosed < -5 && slopeCurrent < -5) {
          finalText = "📉 Strong Bearish Match";
          finalClass = "signal-ai-confirmed";
        } else if (slopeClosed > 5 && slopeCurrent < 0) {
          finalText = "⚠️ Diverging: Wait / Caution";
          finalClass = "signal-ai-warning";
        } else if (slopeClosed < -5 && slopeCurrent > 0) {
          finalText = "⚠️ Diverging: Wait / Caution";
          finalClass = "signal-ai-warning";
        } else if (Math.abs(slopeClosed) < 5 && Math.abs(slopeCurrent) > 10) {
          finalText = slopeCurrent > 0 ? "🔄 Sudden Buyer Surge" : "🔄 Sudden Seller Surge";
          finalClass = slopeCurrent > 0 ? "signal-ai-bullish" : "signal-ai-bearish";
        }

        finalAI.innerText = finalText;
        finalAI.className = finalClass;
      } else {
        finalAI.innerText = "Waiting for Data...";
        finalAI.className = "signal-ai-neutral";
      }
    }

    // ========== ADVANCED CVD FEATURES ========== //
    function detectVolumeSpike() {
      if (candles.length < 6) return { text: "--", class: "" };
      const last5 = candles.slice(-5);
      const cvds = last5.map(c => c.buyVolume - c.sellVolume);
      const avgBuy = cvds.slice(0, 4).reduce((a, b) => a + b, 0) / 4;
      const suddenBuy = cvds[4] > avgBuy * 3;
      const suddenSell = cvds[4] < avgBuy * -3;

      if (suddenBuy) return { text: "⚡ Whale Buy Spike", class: "signal-spike" };
      if (suddenSell) return { text: "⚠️ Whale Sell Spike", class: "signal-spike" };
      return { text: "--", class: "" };
    }

    function detectSmartDivergence() {
      if (candles.length < 6) return { text: "--", class: "" };
      const last5 = candles.slice(-5);
      const highs = last5.map(c => c.high);
      const cvds = last5.map(c => c.buyVolume - c.sellVolume);

      const priceHigherHigh = highs[4] > highs[2] && highs[2] > highs[0];
      const cvdLowerHigh = cvds[4] < cvds[2] && cvds[2] < cvds[0];

      if (priceHigherHigh && cvdLowerHigh) return { text: "📉 Smart Bearish Divergence", class: "signal-bearish-divergence" };
      if (!priceHigherHigh && cvdLowerHigh) return { text: "📈 Smart Bullish Divergence", class: "signal-bullish-divergence" };
      return { text: "--", class: "" };
    }

    function detectWickTrap() {
      if (candles.length < 1) return { text: "--", class: "" };
      const last = candles[candles.length - 1];
      const upperWick = last.high - Math.max(last.open, last.close);
      const lowerWick = Math.min(last.open, last.close) - last.low;
      const totalWick = upperWick + lowerWick;

      if (upperWick > totalWick * 0.7 && (last.buyVolume - last.sellVolume) < 0)
        return { text: "🪤 Liquidity Trap (Up Wick)", class: "signal-trap" };
      if (lowerWick > totalWick * 0.7 && (last.buyVolume - last.sellVolume) > 0)
        return { text: "📥 Spring Wick Accumulation", class: "signal-accumulation" };
      return { text: "--", class: "" };
    }

    function detectOBVCVDMatch() {
      if (candles.length < 6) return { text: "--", class: "" };
      let obv = 0;
      for (let i = 1; i < candles.length; i++) {
        if (candles[i].close > candles[i - 1].close) obv += candles[i].volume;
        else if (candles[i].close < candles[i - 1].close) obv -= candles[i].volume;
      }
      const cvd = candles.map(c => c.buyVolume - c.sellVolume).reduce((a,b) => a + b, 0);

      if (obv > 0 && cvd > 0) return { text: "✅ OBV & CVD Bull Confirm", class: "signal-confirmed" };
      if (obv < 0 && cvd < 0) return { text: "🔻 OBV & CVD Bear Confirm", class: "signal-confirmed" };
      return { text: "--", class: "" };
    }

    function simulateOrderBookImbalance() {
      // Fake values for now (replace with real order book depth via WebSocket)
      const buyDepth = 120000;
      const sellDepth = 80000;
      const total = buyDepth + sellDepth;
      const buyPerc = (buyDepth / total) * 100;
      const sellPerc = 100 - buyPerc;

      if (buyPerc > 65) return { text: `📈 Buy DOM Heavy (${buyPerc.toFixed(1)}%)`, class: "signal-imbalance" };
      if (sellPerc > 65) return { text: `📉 Sell DOM Heavy (${sellPerc.toFixed(1)}%)`, class: "signal-imbalance" };
      return { text: `⚖️ Balanced Book (${buyPerc.toFixed(1)}% / ${sellPerc.toFixed(1)}%)`, class: "" };
    }

    // CVD Acceleration Detection
    function detectCVDAcceleration() {
      if (candles.length < 4) return { text: "--", class: "" };

      const cvd = candles.map(c => c.buyVolume - c.sellVolume);
      const cvdDelta1 = cvd[cvd.length - 1] - cvd[cvd.length - 2];
      const cvdDelta2 = cvd[cvd.length - 2] - cvd[cvd.length - 3];
      const acceleration = cvdDelta1 - cvdDelta2;

      if (acceleration > 100000) {
        return { text: "🚀 Buyer Acceleration Detected", class: "signal-ai-bullish" };
      } else if (acceleration < -100000) {
        return { text: "⚠️ Seller Acceleration Detected", class: "signal-ai-bearish" };
      } else {
        return { text: "--", class: "" };
      }
    }

    // Fakeout Detection
    function detectFakeout() {
      if (candles.length < 3) return { text: "--", class: "" };

      const curr = candles[candles.length - 1];
      const prev = candles[candles.length - 2];

      const body = Math.abs(curr.close - curr.open);
      const upperWick = curr.high - Math.max(curr.close, curr.open);
      const lowerWick = Math.min(curr.close, curr.open) - curr.low;
      const wickRatio = (upperWick + lowerWick) / (body + 0.001);
      const cvd = curr.buyVolume - curr.sellVolume;

      if (upperWick > body * 2 && curr.close < curr.open && cvd < 0) {
        return { text: "🪤 Bull Trap Detected", class: "signal-trap" };
      } else if (lowerWick > body * 2 && curr.close > curr.open && cvd > 0) {
        return { text: "📥 Bear Trap (Spring Wick)", class: "signal-accumulation" };
      }

      return { text: "--", class: "" };
    }

    // Whale Wall Detection
    function detectWhaleWalls(buyDepth, sellDepth) {
      const total = buyDepth + sellDepth;
      const buyPerc = (buyDepth / total) * 100;
      const sellPerc = (sellDepth / total) * 100;

      if (buyPerc > 70) return { text: `🐋 Whale Buy Wall (${buyPerc.toFixed(1)}%)`, class: "signal-imbalance" };
      if (sellPerc > 70) return { text: `🐋 Whale Sell Wall (${sellPerc.toFixed(1)}%)`, class: "signal-imbalance" };
      return { text: "⚖️ DOM Balanced", class: "" };
    }

    // ========== TREND PREDICTION FEATURES ========== //
    function updateSmartTrendPrediction() {
      const result = {
        bullish: 0,
        bearish: 0,
        neutral: 0,
        reasons: []
      };

      // Get current signals from DOM
      const divergenceSignal = document.getElementById("divergenceSignal").innerText;
      const volumeSpikeSignal = document.getElementById("volumeSpikeSignal").innerText;
      const cvdAcceleration = document.getElementById("cvdAccelerationSignal").innerText;
      const wickTrapSignal = document.getElementById("wickTrapSignal").innerText;
      const fakeoutSignal = document.getElementById("fakeoutSignal").innerText;
      const obvCvdSignal = document.getElementById("obvCvdSignal").innerText;
      const smartTrapText = document.getElementById("smartTrapText").innerText;
      const zoneMemoryText = document.getElementById("zoneMemoryText").innerText;
      const whaleWall = document.getElementById("whaleWallSignal").innerText;

      // Get slopes for dual slope analysis
      let slopeClosed = 0;
      let slopeCurrent = 0;
      const closedCandles = candles.filter(c => c.isClosed);
      if (closedCandles.length >= 5) {
        const last5Closed = closedCandles.slice(-5);
        const cvdsClosed = last5Closed.map(c => c.buyVolume - c.sellVolume);
        slopeClosed = ((cvdsClosed[4] - cvdsClosed[0]) / Math.abs(cvdsClosed[0] || 1)) * 100;
      }
      if (candles.length >= 5) {
        const last5All = candles.slice(-5);
        const cvdsAll = last5All.map(c => c.buyVolume - c.sellVolume);
        slopeCurrent = ((cvdsAll[4] - cvdsAll[0]) / Math.abs(cvdsAll[0] || 1)) * 100;
      }

      // 1. Dual Slope CVD
      if (slopeClosed > 5 && slopeCurrent > 5) {
        result.bullish++; result.reasons.push("Dual Slope Bullish");
      } else if (slopeClosed < -5 && slopeCurrent < -5) {
        result.bearish++; result.reasons.push("Dual Slope Bearish");
      }

      // 2. Divergence
      if (divergenceSignal.includes("Bullish")) {
        result.bullish++; result.reasons.push("Bullish Divergence");
      } else if (divergenceSignal.includes("Bearish")) {
        result.bearish++; result.reasons.push("Bearish Divergence");
      }

      // 3. Volume Spike + Acceleration
      if (volumeSpikeSignal.includes("Buy") || cvdAcceleration.includes("Buyer")) {
        result.bullish++; result.reasons.push("Volume Spike");
      } else if (volumeSpikeSignal.includes("Sell") || cvdAcceleration.includes("Seller")) {
        result.bearish++; result.reasons.push("Sell Acceleration");
      }

      // 4. Wick Trap
      if (wickTrapSignal.includes("Spring") || fakeoutSignal.includes("Bear Trap")) {
        result.bullish++; result.reasons.push("Spring Wick");
      } else if (wickTrapSignal.includes("Liquidity Trap") || fakeoutSignal.includes("Bull Trap")) {
        result.bearish++; result.reasons.push("Bull Trap");
      }

      // 5. OBV Conflict
      if (obvCvdSignal.includes("Bull Confirm")) {
        result.bullish++; result.reasons.push("OBV+CVD Confirm");
      } else if (obvCvdSignal.includes("Bear Confirm")) {
        result.bearish++; result.reasons.push("OBV+CVD Bear");
      }

      // 6. Smart Trap
      if (smartTrapText.includes("Spring")) {
        result.bullish++; result.reasons.push("Smart Spring");
      } else if (smartTrapText.includes("Bull Trap")) {
        result.bearish++; result.reasons.push("Smart Trap");
      }

      // 7. Order Book Pressure + Wick Memory
      if (zoneMemoryText.includes("Support") || whaleWall.includes("Buy Wall")) {
        result.bullish++; result.reasons.push("DOM + Support Memory");
      } else if (zoneMemoryText.includes("Resistance") || whaleWall.includes("Sell Wall")) {
        result.bearish++; result.reasons.push("DOM + Resistance");
      }

      // FINAL OUTPUT
      const trendBox = document.getElementById("trendChangeText");
      if (result.bullish >= 5) {
        trendBox.innerText = `🚀 Strong Bullish Reversal (${result.bullish}/7) - ${result.reasons.join(", ")}`;
        trendBox.className = "signal-ai-confirmed";
      } else if (result.bearish >= 5) {
        trendBox.innerText = `⚠️ Strong Bearish Reversal (${result.bearish}/7) - ${result.reasons.join(", ")}`;
        trendBox.className = "signal-ai-warning";
      } else {
        trendBox.innerText = `Neutral / Mixed (${result.bullish}B / ${result.bearish}S)`;
        trendBox.className = "signal-ai-neutral";
      }
    }

    function detectSmartTrap() {
      if (candles.length < 3) return;
      const last = candles[candles.length - 1];
      const prev = candles[candles.length - 2];
      const upperWick = last.high - Math.max(last.open, last.close);
      const lowerWick = Math.min(last.open, last.close) - last.low;
      const body = Math.abs(last.open - last.close);
      const cvd = last.buyVolume - last.sellVolume;
      const trapBox = document.getElementById("smartTrapText");

      if (upperWick > body * 2 && last.close < last.open && cvd < 0) {
        trapBox.innerText = "🪤 Bull Trap Detected";
        trapBox.className = "signal-trap-detect";
      } else if (lowerWick > body * 2 && last.close > last.open && cvd > 0) {
        trapBox.innerText = "👥 Spring Trap Detected";
        trapBox.className = "signal-trap-detect";
      } else {
        trapBox.innerText = "No Trap";
        trapBox.className = "";
      }
    }

    function detectOrderBookPressure(buyDepth, sellDepth) {
      const total = buyDepth + sellDepth;
      const buyPerc = (buyDepth / total) * 100;
      const sellPerc = 100 - buyPerc;
      const pressureBox = document.getElementById("orderBookSignal");

      if (buyPerc > 65) {
        pressureBox.innerText = `💲 Buy Pressure (${buyPerc.toFixed(1)}%)`;
        pressureBox.className = "signal-trend-alert";
      } else if (sellPerc > 65) {
        pressureBox.innerText = `💸 Sell Pressure (${sellPerc.toFixed(1)}%)`;
        pressureBox.className = "signal-trend-alert";
      } else {
        pressureBox.innerText = `⚖️ Neutral Order Book`;
        pressureBox.className = "";
      }
    }

    function showLiquidityZoneMemory() {
      if (candles.length < 6) return;
      const zoneBox = document.getElementById("zoneMemoryText");
      const zoneCandles = candles.slice(-6, -1);
      const wicks = zoneCandles.map(c => ({
        upper: c.high - Math.max(c.open, c.close),
        lower: Math.min(c.open, c.close) - c.low
      }));
      const upperAvg = wicks.reduce((sum, w) => sum + w.upper, 0) / wicks.length;
      const lowerAvg = wicks.reduce((sum, w) => sum + w.lower, 0) / wicks.length;

      if (upperAvg > lowerAvg * 1.5) {
        zoneBox.innerText = "🚩 Liquidity Absorption Above (Resistance Memory)";
        zoneBox.className = "signal-zone-memory";
      } else if (lowerAvg > upperAvg * 1.5) {
        zoneBox.innerText = "📅 Liquidity Spring Below (Support Memory)";
        zoneBox.className = "signal-zone-memory";
      } else {
        zoneBox.innerText = "No Major Zone Detected";
        zoneBox.className = "";
      }
    }

    function updateAdvancedFeatures() {
      // Volume Spike Detection
      const volumeSpike = detectVolumeSpike();
      document.getElementById("volumeSpikeSignal").innerText = volumeSpike.text;
      document.getElementById("volumeSpikeSignal").className = volumeSpike.class;

      // Smart Divergence Detection
      const smartDivergence = detectSmartDivergence();
      document.getElementById("smartDivergenceSignal").innerText = smartDivergence.text;
      document.getElementById("smartDivergenceSignal").className = smartDivergence.class;

      // Wick Trap Detection
      const wickTrap = detectWickTrap();
      document.getElementById("wickTrapSignal").innerText = wickTrap.text;
      document.getElementById("wickTrapSignal").className = wickTrap.class;

      // OBV + CVD Confirmation
      const obvCvd = detectOBVCVDMatch();
      document.getElementById("obvCvdSignal").innerText = obvCvd.text;
      document.getElementById("obvCvdSignal").className = obvCvd.class;

      // Order Book Imbalance
      const orderBook = simulateOrderBookImbalance();
      document.getElementById("orderBookSignal").innerText = orderBook.text;
      document.getElementById("orderBookSignal").className = orderBook.class;

      // CVD Acceleration Detection
      const cvdAcceleration = detectCVDAcceleration();
      document.getElementById("cvdAccelerationSignal").innerText = cvdAcceleration.text;
      document.getElementById("cvdAccelerationSignal").className = cvdAcceleration.class;

      // Fakeout Detection
      const fakeout = detectFakeout();
      document.getElementById("fakeoutSignal").innerText = fakeout.text;
      document.getElementById("fakeoutSignal").className = fakeout.class;
      
      // New trend prediction features
      updateSmartTrendPrediction();
      detectSmartTrap();
      showLiquidityZoneMemory();
    }
    // ========== END OF ADVANCED FEATURES ========== //

    // Toggle live data
    toggleLiveBtn.addEventListener('click', () => {
      liveDataEnabled = !liveDataEnabled;
      toggleLiveBtn.textContent = liveDataEnabled ? 'Pause Live Data' : 'Resume Live Data';
      document.querySelector('.live-indicator').style.animation = liveDataEnabled ? 'pulse 1s infinite' : 'none';
      document.querySelector('.live-indicator').style.backgroundColor = liveDataEnabled ? '#dc3545' : '#666';
      
      if (liveDataEnabled) {
        setupWebSocket();
        setupDOMWebSocket();
      } else {
        if (socket) socket.close();
        if (domSocket) domSocket.close();
      }
    });
    
    // Toggle history count
    toggle5Btn.addEventListener('click', () => {
      historyCount = 5;
      toggle5Btn.classList.add('active-toggle');
      toggle10Btn.classList.remove('active-toggle');
      updateHistoryTable();
    });
    
    toggle10Btn.addEventListener('click', () => {
      historyCount = 10;
      toggle10Btn.classList.add('active-toggle');
      toggle5Btn.classList.remove('active-toggle');
      updateHistoryTable();
    });
    
    // Toggle current candle inclusion
    toggleWithCurrentBtn.addEventListener('click', () => {
      includeCurrent = true;
      toggleWithCurrentBtn.classList.add('active-toggle');
      toggleWithoutCurrentBtn.classList.remove('active-toggle');
      updateHistoryTable();
    });
    
    toggleWithoutCurrentBtn.addEventListener('click', () => {
      includeCurrent = false;
      toggleWithoutCurrentBtn.classList.add('active-toggle');
      toggleWithCurrentBtn.classList.remove('active-toggle');
      updateHistoryTable();
    });
    
    // Handle symbol or interval change
    coinSelect.addEventListener('change', () => {
      currentSymbol = coinSelect.value;
      cumulativeCVD = 0;
      loadInitialKlines();
    });
    
    timeframeSelect.addEventListener('change', () => {
      currentInterval = timeframeSelect.value;
      cumulativeCVD = 0;
      loadInitialKlines();
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      initChartDimensions();
      drawChart();
    });
    
    // Search functionality for coins
    coinSearch.addEventListener('input', () => {
      const searchTerm = coinSearch.value.trim();
      populateCoinSelect(allCoins, searchTerm);
    });

    // Mobile menu toggle
    mobileMenuToggle.addEventListener('click', () => {
      leftPanel.classList.toggle('active');
    });
    
    // Initialize everything
    initChartDimensions();
    fetchCoins();
    setupChartInteractions();
  </script>
</body>
</html>