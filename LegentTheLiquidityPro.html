<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Legend The Liquidity Pro</title>
  <style>
    :root {
      --primary-color: #4CAF50;
      --secondary-color: #FF9800;
      --danger-color: #F44336;
      --background-color: #f5f5f5;
      --card-color: #ffffff;
      --text-color: #333333;
      --text-light: #666666;
      --border-color: #e0e0e0;
      --highlight-color: rgba(76, 175, 80, 0.2);
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      padding: 20px;
      margin: 0;
      transition: all 0.3s ease;
      margin: 0 auto;
    }

    body.dark-mode {
      --primary-color: #4CAF50;
      --secondary-color: #FF9800;
      --danger-color: #F44336;
      --background-color: #121212;
      --card-color: #1e1e1e;
      --text-color: #e0e0e0;
      --text-light: #aaaaaa;
      --border-color: #333333;
      --highlight-color: rgba(76, 175, 80, 0.3);
    }

    h1 { 
      color: var(--primary-color); 
      text-align: center;
      margin-bottom: 15px;
      font-size: clamp(1.5rem, 2.5vw, 2rem);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .control-panel {
      background: var(--card-color);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      border: 1px solid var(--border-color);
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    select, button, input { 
      padding: 10px 15px;
      font-size: 14px; 
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: var(--card-color);
      color: var(--text-color);
      box-sizing: border-box;
      transition: all 0.2s;
    }

    select:focus, input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      white-space: nowrap;
    }

    button:hover {
      background-color: #45a049;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:active {
      transform: translateY(0);
    }

    .search-container {
      display: flex;
      justify-content: center;
      width: auto;
      position: relative;
    }

    #coinSearch {
      width: 95%;
      padding-right: 30px;
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      background: var(--card-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .search-result-item {
      padding: 10px;
      cursor: pointer;
      color: var(--text-color);
      transition: background 0.2s;
    }

    .search-result-item:hover {
      background: rgba(76, 175, 80, 0.1);
    }
    
    .result { 
      background: var(--card-color); 
      padding: 15px; 
      margin-top: 15px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      overflow-x: auto;
      border: 1px solid var(--border-color);
    }

    table { 
      width: 100%; 
      border-collapse: separate; 
      border-spacing: 0;
      margin-top: 10px;
      font-size: 13px;
      min-width: 700px;
    }

    th { 
      background-color: var(--primary-color); 
      color: white; 
      font-weight: bold;
      padding: 14px 15px;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    th:first-child {
      border-top-left-radius: 8px;
      border-bottom-left-radius: 8px;
    }

    th:last-child {
      border-top-right-radius: 8px;
      border-bottom-right-radius: 8px;
    }

    td { 
      padding: 12px 15px; 
      text-align: center; 
      border-bottom: 1px solid var(--border-color);
      transition: background 0.2s;
      font-weight: 600;
      font-size: 18px;
    }

    tr:hover td {
      background-color: rgba(76, 175, 80, 0.05);
    }

    .up { 
      color: var(--primary-color); 
      font-weight: bold;
    }

    .down { 
      color: var(--danger-color); 
      font-weight: bold;
    }

    .price-change {
      font-weight: bold;
    }

    .last-update {
      text-align: right;
      font-size: 11px;
      color: var(--text-light);
      margin-top: 8px;
    }

    .symbol-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      width: 100%;
      justify-content: center;
    }

    .current-price {
      font-weight: bold;
      font-size: 16px;
    }

    .timeframe-header {
      background-color: rgba(76, 175, 80, 0.1);
      font-weight: bold;
    }

    .pro-feature { background-color: rgba(0,0,0,0.05); }
    .volume-high { color: var(--primary-color); font-weight: bold; }
    .volume-low { color: var(--danger-color); }
    .power-signal {
      background: linear-gradient(90deg, var(--primary-color), #2E7D32);
      color: white;
      padding: 6px;
      border-radius: 4px;
      display: inline-block;
      font-size: 11px;
    }

    /* Advanced Panel Styles */
    .advanced-panel {
      background: var(--card-color);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-top: 15px;
      display: none;
      overflow-x: auto;
      border: 1px solid var(--border-color);
    }

    .toggle-advanced {
      background-color: #2196F3;
      margin-top: 8px;
    }

    .toggle-advanced:hover {
      background-color: #0b7dda;
    }

    .settings-panel {
      background: var(--card-color);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      border: 1px solid var(--border-color);
    }

    .settings-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      align-items: center;
    }

    .settings-label {
      font-weight: bold;
      min-width: 150px;
      color: var(--text-color);
    }

    .settings-value {
      flex-grow: 1;
    }

    .settings-input {
      width: 80px;
      padding: 8px;
      border-radius: 4px;
    }

    .highlight {
      animation: pulse 1.5s infinite;
      position: relative;
    }

    @keyframes pulse {
      0% { background-color: rgba(76, 175, 80, 0.1); }
      50% { background-color: rgba(76, 175, 80, 0.3); }
      100% { background-color: rgba(76, 175, 80, 0.1); }
    }

    .settings-toggle {
      background: rgba(76, 175, 80, 0.1);
      border: none;
      color: var(--primary-color);
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 10px;
      transition: all 0.2s;
    }

    .settings-toggle:hover {
      background: rgba(76, 175, 80, 0.2);
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .checkbox-item input[type="checkbox"] {
      accent-color: var(--primary-color);
      width: 18px;
      height: 18px;
    }

    .metric-name {
      text-align: left;
      width: 150px;
      font-weight: bold;
      background-color: rgba(76, 175, 80, 0.1);
      color: var(--text-color);
    }

    .value {
      font-weight: bold;
    }

    .green {
      color: var(--primary-color);
    }

    .red {
      color: var(--danger-color);
    }

    /* Loading spinner */
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border-left-color: var(--primary-color);
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Theme toggle */
    .theme-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--primary-color);
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 100;
      border: none;
      font-size: 20px;
    }

    /* Responsive adjustments */
    @media (min-width: 768px) {
      .control-panel > *:not(.search-container):not(.symbol-info) {
        flex: 1 1 auto;
        max-width: 200px;
      }
      .symbol-info {
        width: auto;
        justify-content: flex-start;
      }
      #coinSearch {
        width: 70%;
      }
      table {
        font-size: 14px;
      }
      th, td {
        padding: 10px;
      }
    }
    
    @media (max-width: 480px) {
      .control-panel {
        flex-direction: column;
        align-items: stretch;
      }
      select, button, input {
        width: 100%;
      }
    }
  </style>
</head>
<body>

<h1>Legend The Liquidity Pro</h1>

<div class="control-panel">
  <div class="search-container">
    <input type="text" id="coinSearch" placeholder="Search coin...">
    <div class="search-results" id="searchResults"></div>
  </div>
  <select id="symbolSelect"></select>
  <select id="candleCountSelect">
    <option value="3">Weak (3 candles)</option>
    <option value="5">Strong (5 candles)</option>
    <option value="7" selected>Kill (7 candles)</option>
  </select>
  <button onclick="startModel()">Start Analysis</button>
  <button class="toggle-advanced" onclick="toggleAdvancedPanel()">Show History</button>
  <button class="settings-toggle" onclick="toggleSettings()">‚öôÔ∏è Settings</button>
  <div class="symbol-info">
    <span id="currentSymbol"></span>
    <span class="current-price" id="currentPrice"></span>
    <span class="price-change" id="priceChange"></span>
  </div>
</div>

<div class="settings-panel" id="settingsPanel">
  <div class="settings-row">
    <div class="settings-label">Price Proximity Alerts:</div>
    <div class="settings-value">
      <input type="checkbox" id="proximityAlerts" checked>
      <label for="proximityAlerts">Enable alerts</label>
    </div>
  </div>
  <div class="settings-row">
    <div class="settings-label">Proximity Threshold:</div>
    <div class="settings-value">
      <input type="number" id="proximityThreshold" class="settings-input" value="1.0" step="0.1" min="0.1" max="5.0"> %
    </div>
  </div>
  <div class="settings-row">
    <div class="settings-label">Expansion Factor:</div>
    <div class="settings-value">
      <input type="number" id="expansionFactor" class="settings-input" value="0.25" step="0.05" min="0.1" max="1.0">
    </div>
  </div>
  <div class="settings-row">
    <div class="settings-label">Show Timeframes:</div>
    <div class="settings-value">
      <div class="checkbox-group" id="timeframeCheckboxes"></div>
    </div>
  </div>
  <div class="settings-row">
    <button onclick="applySettings()">Apply Settings</button>
  </div>
</div>

<div id="output" class="result"></div>

<div class="dashboard result" id="liquidityDashboard" style="display: none;">
  <table id="dataTable">
    <thead>
      <tr id="timeframeHeaders"></tr>
    </thead>
    <tbody>
      <tr id="swingHighRow"></tr>
      <tr id="swingLowRow"></tr>
      <tr id="upTargetRow"></tr>
      <tr id="downTargetRow"></tr>
    </tbody>
  </table>
  <div class="last-update" id="dashboardLastUpdate"></div>
</div>

<div id="advancedPanel" class="advanced-panel">
  <h3>History Analysis</h3>
  <div class="table-responsive">
    <table>
      <thead>
        <tr>
          <th>Time Frame</th>
          <th>Volume</th>
          <th>Candle Type</th>
          <th>Direction</th>
          <th>Range Size</th>
          <th>Resistance</th>
          <th>Support</th>
          <th>ATR Expansion</th>
          <th>Resistance / Support</th>
        </tr>
      </thead>
      <tbody id="advancedBody">
        <!-- Rows will be added dynamically -->
      </tbody>
    </table>
  </div>
  <div class="last-update" id="advancedLastUpdate"></div>
</div>

<button class="theme-toggle" id="themeToggle">üåì</button>

<script>
// Fixed timeframes exactly as you requested
const allIntervals = ["15m", "30m", "1h", "4h", "1d", "1w", "1M"];
let activeIntervals = ["15m", "30m", "1h", "4h", "1d", "1w", "1M"];
let symbol = "";
let priceUpdateInterval;
let autoUpdateInterval; // Added for automatic updates
let currentPrice = 0;
let allSymbols = [];
let sockets = {};
let lastClosedCandles = {};
let settings = {
  proximityAlerts: true,
  proximityThreshold: 1.0,
  expansionFactor: 0.25,
  darkMode: false
};

// Theme toggle functionality
function toggleTheme() {
  document.body.classList.toggle('dark-mode');
  settings.darkMode = document.body.classList.contains('dark-mode');
  saveSettings();
}

function toggleSettings() {
  const panel = document.getElementById("settingsPanel");
  panel.style.display = panel.style.display === "none" ? "block" : "none";
}

function applySettings() {
  settings.proximityAlerts = document.getElementById("proximityAlerts").checked;
  settings.proximityThreshold = parseFloat(document.getElementById("proximityThreshold").value);
  settings.expansionFactor = parseFloat(document.getElementById("expansionFactor").value);
  
  // Update active timeframes
  activeIntervals = [];
  allIntervals.forEach(interval => {
    if (document.getElementById(`checkbox-${interval}`).checked) {
      activeIntervals.push(interval);
    }
  });
  
  // Recalculate all levels if symbol is selected
  if (symbol) {
    activeIntervals.forEach(interval => {
      if (lastClosedCandles[interval]) {
        calculateLevels(interval);
      }
    });
  }
  
  // Hide settings panel
  document.getElementById("settingsPanel").style.display = "none";
  saveSettings();
}

// Initialize the timeframe checkboxes
function initTimeframeCheckboxes() {
  const container = document.getElementById("timeframeCheckboxes");
  container.innerHTML = '';
  
  allIntervals.forEach(interval => {
    const div = document.createElement("div");
    div.className = "checkbox-item";
    
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = `checkbox-${interval}`;
    checkbox.value = interval;
    checkbox.checked = activeIntervals.includes(interval);
    
    const label = document.createElement("label");
    label.htmlFor = `checkbox-${interval}`;
    label.textContent = interval;
    
    div.appendChild(checkbox);
    div.appendChild(label);
    container.appendChild(div);
  });
}

// Added function for automatic updates
function startAutoUpdate() {
  // Clear any existing interval
  if (autoUpdateInterval) {
    clearInterval(autoUpdateInterval);
  }
  
  // Start new interval (5000ms = 5 seconds)
  autoUpdateInterval = setInterval(() => {
    if (symbol) {
      // Update the main analysis
      allIntervals.forEach(tf => {
        fetchCandleData(symbol, tf);
      });
      
      // Update the dashboard levels
      activeIntervals.forEach(interval => {
        if (lastClosedCandles[interval]) {
          calculateLevels(interval);
        }
      });
      
      // Update current price
      updateCurrentPrice();
    }
  }, 5000);
}

async function fetchSymbols() {
  try {
    const res = await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo");
    const data = await res.json();
    const select = document.getElementById("symbolSelect");
    
    // Clear existing options
    select.innerHTML = '';
    
    // Store all symbols and add USDT pairs sorted alphabetically
    allSymbols = data.symbols
      .filter(s => s.symbol.endsWith("USDT") && !s.symbol.includes("_"))
      .sort((a, b) => a.symbol.localeCompare(b.symbol));
    
    allSymbols.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.symbol;
      opt.textContent = s.symbol;
      select.appendChild(opt);
    });
    
    // Set default symbol
    if (select.options.length > 0) {
      symbol = select.options[0].value;
      updateCurrentPrice();
    }
    
    // Setup search functionality
    setupSearch();
  } catch (error) {
    console.error("Error fetching symbols:", error);
  }
}

function setupSearch() {
  const searchInput = document.getElementById("coinSearch");
  const searchResults = document.getElementById("searchResults");
  
  searchInput.addEventListener("input", function() {
    const searchTerm = this.value.toUpperCase();
    searchResults.innerHTML = '';
    
    if (searchTerm.length < 2) {
      searchResults.style.display = 'none';
      return;
    }
    
    const filtered = allSymbols.filter(s => s.symbol.includes(searchTerm));
    
    if (filtered.length > 0) {
      filtered.forEach(symbol => {
        const item = document.createElement("div");
        item.className = "search-result-item";
        item.textContent = symbol.symbol;
        item.addEventListener('click', function() {
          document.getElementById("symbolSelect").value = symbol.symbol;
          searchInput.value = symbol.symbol;
          searchResults.style.display = 'none';
        });
        searchResults.appendChild(item);
      });
      searchResults.style.display = 'block';
    } else {
      searchResults.style.display = 'none';
    }
  });
  
  // Hide results when clicking elsewhere
  document.addEventListener('click', function(e) {
    if (e.target !== searchInput) {
      searchResults.style.display = 'none';
    }
  });
}

function startModel() {
  // Close all existing sockets
  Object.values(sockets).forEach(socket => {
    if (socket) socket.close();
  });
  sockets = {};

  symbol = document.getElementById("symbolSelect").value;
  document.getElementById("currentSymbol").textContent = symbol;
  
  // Clear and setup table headers for dashboard
  const headersRow = document.getElementById("timeframeHeaders");
  headersRow.innerHTML = '<td class="metric-name">Time Frame</td>';
  
  // Clear and setup data rows for dashboard
  document.getElementById("swingHighRow").innerHTML = '<td class="metric-name">Swing High</td>';
  document.getElementById("swingLowRow").innerHTML = '<td class="metric-name">Swing Low</td>';
  document.getElementById("upTargetRow").innerHTML = '<td class="metric-name">Resistance</td>';
  document.getElementById("downTargetRow").innerHTML = '<td class="metric-name">Support</td>';
  
  // Add columns for active timeframes only
  activeIntervals.forEach(interval => {
    // Add header
    const headerCell = document.createElement("th");
    headerCell.textContent = interval;
    headersRow.appendChild(headerCell);
    
    // Add cells for each metric
    addDataCell("swingHighRow", interval, "Loading...");
    addDataCell("swingLowRow", interval, "Loading...");
    addDataCell("upTargetRow", interval, "Loading...");
    addDataCell("downTargetRow", interval, "Loading...");
    
    // Initialize data structure and connect
    lastClosedCandles[interval] = [];
    fetchHistoricalData(interval);
    connectWebSocket(interval);
  });

  // Show the dashboard
  document.getElementById("liquidityDashboard").style.display = "block";

  // Clear previous results for standard analysis
  document.getElementById("output").innerHTML = `
    <div style="text-align: center; padding: 20px;">
      <div class="spinner"></div>
      <p>Loading liquidity projections...</p>
    </div>
  `;

  // Start live price updates
  clearInterval(priceUpdateInterval);
  updateCurrentPrice();
  priceUpdateInterval = setInterval(updateCurrentPrice, 3000);

  // Start auto-update every 5 seconds
  startAutoUpdate();

  // Create result table structure for standard analysis
  setTimeout(() => {
    const resultTable = `
      <div class="table-responsive">
        <table>
          <thead>
            <tr>
              <th>Time Frame</th>
              <th>Volume</th>
              <th>Direction</th>
              <th>Range Size</th>
              <th>Resistance</th>
              <th>Support</th>
              <th>ATR Expansion</th>
              <th>Resistance / Support</th>
            </tr>
          </thead>
          <tbody id="resultBody">
            ${allIntervals.map(tf => `
              <tr id="row_${tf.replace(/\W/g, '_')}">
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
                <td>Loading...</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div class="last-update" id="lastUpdate"></div>
    `;
    
    document.getElementById("output").innerHTML = resultTable;
    
    // Fetch data for all timeframes in order
    allIntervals.forEach((tf, index) => {
      setTimeout(() => {
        fetchCandleData(symbol, tf);
      }, index * 300); // Stagger requests slightly
    });
    
    // Also fetch advanced data
    fetchAdvancedData();
  }, 500);
}

function addDataCell(rowId, interval, value) {
  const cell = document.createElement("td");
  cell.className = "value";
  cell.id = `${rowId}-${interval}`;
  cell.textContent = value;
  document.getElementById(rowId).appendChild(cell);
}

async function fetchHistoricalData(interval) {
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=100`;
  const candles = await fetch(url).then(res => res.json());

  const now = Date.now();
  const closedCandles = candles.filter(c => c[6] < now);
  lastClosedCandles[interval] = closedCandles.map(c => ({
    high: parseFloat(c[2]),
    low: parseFloat(c[3]),
    close: parseFloat(c[4]),
    time: c[0]
  }));

  calculateLevels(interval);
}

function connectWebSocket(interval) {
  const wsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`;
  const socket = new WebSocket(wsUrl);
  sockets[interval] = socket;

  socket.onmessage = e => {
    const msg = JSON.parse(e.data);
    const k = msg.k;

    // Update live price (only show from 1h timeframe to avoid flickering)
    if (interval === "1h") {
      currentPrice = parseFloat(k.c);
      const priceElement = document.getElementById("currentPrice");
      priceElement.textContent = currentPrice.toFixed(6);
      
      // Update price change
      const changeElement = document.getElementById("priceChange");
      if (priceElement.dataset.prevPrice) {
        const prevPrice = parseFloat(priceElement.dataset.prevPrice);
        const change = ((currentPrice - prevPrice) / prevPrice * 100).toFixed(2);
        changeElement.textContent = `${change}%`;
        changeElement.className = `price-change ${currentPrice > prevPrice ? 'up' : 'down'}`;
        
        // Flash animation for price update
        priceElement.style.transition = 'none';
        priceElement.style.color = currentPrice > prevPrice ? 'var(--primary-color)' : 'var(--danger-color)';
        setTimeout(() => {
          priceElement.style.transition = 'color 0.5s ease';
          priceElement.style.color = '';
        }, 100);
      }
      priceElement.dataset.prevPrice = currentPrice;
      
      // Check price proximity if alerts are enabled
      if (settings.proximityAlerts) {
        checkPriceProximity();
      }
    }

    if (k.x) {
      const closedCandle = {
        high: parseFloat(k.h),
        low: parseFloat(k.l),
        close: parseFloat(k.c),
        time: k.t
      };
      lastClosedCandles[interval].push(closedCandle);
      calculateLevels(interval);
    }
  };
}

function checkPriceProximity() {
  // Remove all highlights first
  document.querySelectorAll('.highlight').forEach(el => {
    el.classList.remove('highlight');
  });
  
  // Check if price is within threshold of any important level
  activeIntervals.forEach(interval => {
    const swingHighCell = document.getElementById(`swingHighRow-${interval}`);
    const swingLowCell = document.getElementById(`swingLowRow-${interval}`);
    const upTargetCell = document.getElementById(`upTargetRow-${interval}`);
    const downTargetCell = document.getElementById(`downTargetRow-${interval}`);
    
    if (swingHighCell && swingLowCell && upTargetCell && downTargetCell) {
      const swingHigh = parseFloat(swingHighCell.textContent);
      const swingLow = parseFloat(swingLowCell.textContent);
      const upTarget = parseFloat(upTargetCell.textContent);
      const downTarget = parseFloat(downTargetCell.textContent);
      
      const threshold = currentPrice * (settings.proximityThreshold / 100);
      
      if (Math.abs(currentPrice - swingHigh) < threshold) {
        swingHighCell.classList.add('highlight');
      }
      if (Math.abs(currentPrice - swingLow) < threshold) {
        swingLowCell.classList.add('highlight');
      }
      if (Math.abs(currentPrice - upTarget) < threshold) {
        upTargetCell.classList.add('highlight');
      }
      if (Math.abs(currentPrice - downTarget) < threshold) {
        downTargetCell.classList.add('highlight');
      }
    }
  });
}

function calculateLevels(interval) {
  const candles = lastClosedCandles[interval];
  const candleCount = parseInt(document.getElementById("candleCountSelect").value);
  
  if (candles.length < candleCount) return;

  // Take only the last N candles based on selection
  const lastNCandles = candles.slice(-candleCount);
  const highs = lastNCandles.map(c => c.high);
  const lows = lastNCandles.map(c => c.low);

  const highestHigh = Math.max(...highs);
  const lowestLow = Math.min(...lows);
  const expansionRange = (highestHigh - lowestLow) * settings.expansionFactor;

  // Update all cells for this interval
  document.getElementById(`swingHighRow-${interval}`).textContent = highestHigh.toFixed(6);
  document.getElementById(`swingHighRow-${interval}`).classList.add("green");
  document.getElementById(`swingLowRow-${interval}`).textContent = lowestLow.toFixed(6);
  document.getElementById(`swingLowRow-${interval}`).classList.add("red");
  
  const upTarget = highestHigh + expansionRange;
  const downTarget = lowestLow - expansionRange;
  
  const upTargetCell = document.getElementById(`upTargetRow-${interval}`);
  upTargetCell.textContent = upTarget.toFixed(6);
  upTargetCell.className = currentPrice > upTarget ? "value up" : "value";
  
  const downTargetCell = document.getElementById(`downTargetRow-${interval}`);
  downTargetCell.textContent = downTarget.toFixed(6);
  downTargetCell.className = currentPrice < downTarget ? "value down" : "value";
  
  // Check price proximity if alerts are enabled
  if (interval === "1h" && settings.proximityAlerts) {
    checkPriceProximity();
  }

  // Update timestamp
  document.getElementById("dashboardLastUpdate").textContent = `Last updated: ${new Date().toLocaleString()}`;
}

async function updateCurrentPrice() {
  try {
    const url = `https://fapi.binance.com/fapi/v1/ticker/price?symbol=${symbol}`;
    const response = await fetch(url);
    const data = await response.json();
    
    const newPrice = parseFloat(data.price);
    const priceElement = document.getElementById("currentPrice");
    const changeElement = document.getElementById("priceChange");
    
    if (currentPrice > 0) {
      const change = ((newPrice - currentPrice) / currentPrice * 100).toFixed(2);
      changeElement.textContent = `${change}%`;
      changeElement.className = `price-change ${newPrice > currentPrice ? 'up' : 'down'}`;
      
      // Flash animation for price update
      priceElement.style.transition = 'none';
      priceElement.style.color = newPrice > currentPrice ? 'var(--primary-color)' : 'var(--danger-color)';
      setTimeout(() => {
        priceElement.style.transition = 'color 0.5s ease';
        priceElement.style.color = '';
      }, 100);
    }
    
    currentPrice = newPrice;
    priceElement.textContent = newPrice.toFixed(6);
    
    // Update distance calculations if results are already displayed
    if (document.getElementById("resultBody")) {
      updateDistanceToTargets();
    }
    
    // Update advanced panel distances if visible
    if (document.getElementById("advancedBody")) {
      updateAdvancedDistanceToTargets();
    }

    // Update dashboard price levels
    activeIntervals.forEach(interval => {
      if (lastClosedCandles[interval]) {
        calculateLevels(interval);
      }
    });
  } catch (error) {
    console.error("Error updating price:", error);
  }
}

async function getEnhancedData(symbol, timeframe) {
  // 1. Volume Check
  const volumeData = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=20`).then(r => r.json());
  const currentVolume = parseFloat(volumeData[volumeData.length-1][5]);
  const avgVolume = volumeData.reduce((sum, c) => sum + parseFloat(c[5]), 0) / 20;
  const isHighVolume = currentVolume > avgVolume * 1.5;

  // 2. Smart Expansion (ATR Based)
  const atrData = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=14`).then(r => r.json());
  let atr = 0;
  for (let i = 1; i < 14; i++) {
    const tr = Math.max(
      atrData[i][2] - atrData[i][3],
      Math.abs(atrData[i][2] - atrData[i-1][4]),
      Math.abs(atrData[i][3] - atrData[i-1][4])
    );
    atr += tr;
  }
  const smartExpansion = (atr / 14) * 0.6;

  return {
    isHighVolume,
    volumeRatio: (currentVolume/avgVolume).toFixed(2),
    smartExpansion: smartExpansion.toFixed(4),
    newTarget: null // Calculated later
  };
}

async function fetchCandleData(sym, tf) {
  try {
    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${tf}&limit=3`;
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.length < 2) {
      console.error(`Not enough data for ${tf}`);
      return;
    }
    
    const candle = data[data.length - 2]; // Second last candle
    const currentCandle = data[data.length - 1]; // Current candle (incomplete)
    
    const high = parseFloat(candle[2]);
    const low = parseFloat(candle[3]);
    const open = parseFloat(candle[1]);
    const close = parseFloat(candle[4]);
    const range = high - low;
    
    // Wick analysis
    const upperWick = high - Math.max(open, close);
    const lowerWick = Math.min(open, close) - low;
    const bodySize = Math.abs(close - open);
    
    // Calculate liquidity targets for both sides
    const upLiquidity = high + (upperWick * 1.0); // 1.0 multiplier can be adjusted
    const downLiquidity = low - (lowerWick * 1.0);
    
    // Optional bias indicator (keeps existing logic)
    let bias = "";
    if (upperWick > lowerWick * 1.2) {
      bias = "Down";
    } else if (lowerWick > upperWick * 1.2) {
      bias = "Up";
    } else {
      bias = "Neutral";
    }
    
    // Get enhanced data
    const {isHighVolume, volumeRatio, smartExpansion} = await getEnhancedData(sym, tf);
    const enhancedUpTarget = high + parseFloat(smartExpansion);
    const enhancedDownTarget = low - parseFloat(smartExpansion);
    
    const rowId = `row_${tf.replace(/\W/g, '_')}`;
    const row = document.getElementById(rowId);
    if (row) {
      row.innerHTML = `
        <td><strong>${tf}</strong></td>
        <td class="${isHighVolume ? 'volume-high' : 'volume-low'}">${volumeRatio}x</td>
        <td class="${bias.toLowerCase()}">${bias}</td>
        <td>${range.toFixed(3)}</td>
        <td class="red"><b>${upLiquidity.toFixed(6)}</b></td>
        <td class="green"><b>${downLiquidity.toFixed(6)}</b></td>
        <td>${smartExpansion}</td>
        <td><b> <span class="red"> ${enhancedUpTarget.toFixed(6)}</span> / <span class="green">${enhancedDownTarget.toFixed(6)}</span></b></td>
      `; 
    }
    
    // Update timestamp
    document.getElementById("lastUpdate").textContent = `Last updated: ${new Date().toLocaleString()}`;
  } catch (error) {
    console.error(`Error fetching ${tf} data:`, error);
    const rowId = `row_${tf.replace(/\W/g, '_')}`;
    const row = document.getElementById(rowId);
    if (row) {
      row.innerHTML = `
        <td><strong>${tf}</strong></td>
        <td colspan="7" style="color: red;">Error loading data</td>
      `;
    }
  }
}

function updateDistanceToTargets() {
  allIntervals.forEach(tf => {
    const rowId = `row_${tf.replace(/\W/g, '_')}`;
    const row = document.getElementById(rowId);
    if (row) {
      const direction = row.querySelector("td:nth-child(2)").textContent;
      const upLiquidityCell = row.querySelector("td:nth-child(3)");
      const downLiquidityCell = row.querySelector("td:nth-child(4)");
      const enhancedTargetCell = row.querySelector("td:nth-child(8)");
      
      if (upLiquidityCell && upLiquidityCell.textContent !== '-') {
        const upTarget = parseFloat(upLiquidityCell.textContent);
      }
      
      if (downLiquidityCell && downLiquidityCell.textContent !== '-') {
        const downTarget = parseFloat(downLiquidityCell.textContent);
      }
      
      if (enhancedTargetCell && enhancedTargetCell.textContent !== '-') {
        const enhancedTargets = enhancedTargetCell.textContent.split('/');
        const enhancedUpTarget = parseFloat(enhancedTargets[0]);
        const enhancedDownTarget = parseFloat(enhancedTargets[1]);
      }
    }
  });
  
  // Update timestamp
  document.getElementById("lastUpdate").textContent = `Last updated: ${new Date().toLocaleString()}`;
}

// Advanced Panel Functions
function toggleAdvancedPanel() {
  const panel = document.getElementById("advancedPanel");
  const button = document.querySelector(".toggle-advanced");
  
  if (panel.style.display === "none" || !panel.style.display) {
    panel.style.display = "block";
    button.textContent = "Hide History";
    // If advanced panel is empty, fetch data
    if (document.getElementById("advancedBody").children.length === 0) {
      fetchAdvancedData();
    }
  } else {
    panel.style.display = "none";
    button.textContent = "Show History";
  }
}

async function fetchAdvancedData() {
  const advancedTimeframes = ["1d", "1w", "1M"];
  const candleTypes = ["3 Last", "4 Last"];
  
  // Clear previous results
  document.getElementById("advancedBody").innerHTML = "";
  
  for (const tf of advancedTimeframes) {
    for (const candleType of candleTypes) {
      const limit = candleType === "3 Last" ? 4 : 5; // Get 4 candles for 3 last, 5 for 4 last
      
      try {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.length < limit) {
          console.error(`Not enough data for ${tf} ${candleType}`);
          continue;
        }
        
        // Select the appropriate candle (3rd last or 4th last)
        const candleIndex = candleType === "3 Last" ? data.length - 3 : data.length - 4;
        const candle = data[candleIndex];
        
        const high = parseFloat(candle[2]);
        const low = parseFloat(candle[3]);
        const open = parseFloat(candle[1]);
        const close = parseFloat(candle[4]);
        const range = high - low;
        
        // Wick analysis
        const upperWick = high - Math.max(open, close);
        const lowerWick = Math.min(open, close) - low;
        
        // Calculate both liquidity targets
        const upLiquidity = high + (upperWick * 1.0);
        const downLiquidity = low - (lowerWick * 1.0);
        
        // Optional bias indicator
        let bias = "";
        if (upperWick > lowerWick * 1.2) {
          bias = "Down";
        } else if (lowerWick > upperWick * 1.2) {
          bias = "Up";
        } else {
          bias = "Neutral";
        }
        
        // Get enhanced data
        const {isHighVolume, volumeRatio, smartExpansion} = await getEnhancedData(symbol, tf);
        const enhancedUpTarget = high + parseFloat(smartExpansion);
        const enhancedDownTarget = low - parseFloat(smartExpansion);
        
        // Add row to advanced panel
        const row = document.createElement("tr");
        row.innerHTML = `
          <td><strong>${tf}</strong></td>
          <td class="${isHighVolume ? 'volume-high' : 'volume-low'}">${volumeRatio}x</td>
          <td>${candleType}</td>
          <td class="${bias.toLowerCase()}">${bias}</td>
          <td>${range.toFixed(6)}</td>
          <td><b>${upLiquidity.toFixed(6)}</b></td>
          <td><b>${downLiquidity.toFixed(6)}</b></td>
          <td>${smartExpansion}</td>
          <td><b>${enhancedUpTarget.toFixed(6)} / ${enhancedDownTarget.toFixed(6)}</b></td>
        `;

        document.getElementById("advancedBody").appendChild(row);
        
      } catch (error) {
        console.error(`Error fetching ${tf} ${candleType} data:`, error);
        const row = document.createElement("tr");
        row.innerHTML = `
          <td><strong>${tf}</strong></td>
          <td>${candleType}</td>
          <td colspan="7" style="color: red;">Error loading data</td>
        `;
        document.getElementById("advancedBody").appendChild(row);
      }
    }
  }
  
  // Update timestamp
  document.getElementById("advancedLastUpdate").textContent = `Last updated: ${new Date().toLocaleString()}`;
}

function updateAdvancedDistanceToTargets() {
  const rows = document.getElementById("advancedBody").querySelectorAll("tr");
  
  rows.forEach(row => {
    const direction = row.querySelector("td:nth-child(3)").textContent;
    const upLiquidityCell = row.querySelector("td:nth-child(4)");
    const downLiquidityCell = row.querySelector("td:nth-child(5)");
    const enhancedTargetCell = row.querySelector("td:nth-child(9)");
    
    if (upLiquidityCell && upLiquidityCell.textContent !== '-') {
      const upTarget = parseFloat(upLiquidityCell.textContent);
    }
    
    if (downLiquidityCell && downLiquidityCell.textContent !== '-') {
      const downTarget = parseFloat(downLiquidityCell.textContent);
    }
    
    if (enhancedTargetCell && enhancedTargetCell.textContent !== '-') {
      const enhancedTargets = enhancedTargetCell.textContent.split('/');
      const enhancedUpTarget = parseFloat(enhancedTargets[0]);
      const enhancedDownTarget = parseFloat(enhancedTargets[1]);
    }
  });
  
  // Update timestamp
  document.getElementById("advancedLastUpdate").textContent = `Last updated: ${new Date().toLocaleString()}`;
}

// Initialize the dashboard
function initializeDashboard() {
  // Load settings from localStorage if available
  const savedSettings = localStorage.getItem('srDashboardSettings');
  if (savedSettings) {
    settings = JSON.parse(savedSettings);
    document.getElementById("proximityAlerts").checked = settings.proximityAlerts;
    document.getElementById("proximityThreshold").value = settings.proximityThreshold;
    document.getElementById("expansionFactor").value = settings.expansionFactor;
    
    // Apply dark mode if enabled
    if (settings.darkMode) {
      document.body.classList.add('dark-mode');
    }
  }
  
  initTimeframeCheckboxes();
  fetchSymbols();
  
  // Setup theme toggle button
  document.getElementById('themeToggle').addEventListener('click', toggleTheme);
}

// Save settings when changed
function saveSettings() {
  localStorage.setItem('srDashboardSettings', JSON.stringify(settings));
}

// Initialize when page loads
window.onload = initializeDashboard;
</script>

</body>
</html>