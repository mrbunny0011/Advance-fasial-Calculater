<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kalman 14 Candle Signal System</title>
  <style>
    :root {
      --primary-blue: #3498db;
      --primary-green: #2ecc71;
      --primary-red: #e74c3c;
      --primary-orange: #f39c12;
      --primary-purple: #9b59b6;
      --dark-blue: #2980b9;
      --dark-green: #27ae60;
      --dark-red: #c0392b;
      --light-blue: #e1f5fe;
      --light-green: #e8f5e9;
      --light-red: #ffebee;
      --light-orange: #fff3e0;
      --light-purple: #f3e5f5;
      --text-dark: #2c3e50;
      --text-light: #ecf0f1;
      --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: var(--bg-gradient); 
      color: var(--text-dark); 
      padding: 20px;
      line-height: 1.6;
    }
    
    h2 { 
      text-align: center; 
      color: var(--primary-blue); 
      margin-bottom: 25px;
      font-size: 28px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      padding-bottom: 10px;
      border-bottom: 2px solid var(--primary-blue);
    }
    
    .controls { 
      display: flex; 
      justify-content: center; 
      gap: 15px; 
      margin: 25px 0;
      flex-wrap: wrap;
      align-items: center;
      background: rgba(255,255,255,0.8);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    select, input {
      padding: 10px 15px;
      border-radius: 5px;
      background: white;
      color: var(--text-dark);
      border: 1px solid #ddd;
      font-size: 14px;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: var(--primary-blue);
      box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
    }
    
    button {
      padding: 10px 20px;
      border-radius: 5px;
      background: var(--primary-blue);
      color: white;
      border: none;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    button:hover {
      background: var(--dark-blue);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    #loadBtn {
      background-color: var(--primary-green);
      font-weight: bold;
    }
    
    #loadBtn:hover {
      background-color: var(--dark-green);
    }
    
    .search-box {
      position: relative;
    }
    
    .search-box input {
      padding-left: 35px;
      width: 200px;
      background: white url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%237f8c8d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>') no-repeat 10px center;
    }
    
    .price-display {
      text-align: center;
      font-size: 24px;
      margin: 20px 0;
      color: var(--primary-blue);
      font-weight: bold;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: all 0.3s;
    }
    
    .price-display:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0,0,0,0.15);
    }
    
    table { 
      width: 100%; 
      border-collapse: collapse;
      margin: 15px 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    
    th, td { 
      border: 1px solid #e0e0e0; 
      padding: 12px; 
      text-align: center; 
    }
    
    th { 
      background: var(--primary-blue); 
      color: white;
      font-weight: 500;
      position: sticky;
      top: 0;
    }
    
    tr:nth-child(even) {
      background-color: rgba(255,255,255,0.5);
    }
    
    tr:hover {
      background-color: rgba(52,152,219,0.1);
    }
    
    .bullish { 
      color: var(--primary-green); 
      font-weight: bold;
    }
    
    .bearish { 
      color: var(--primary-red); 
      font-weight: bold;
    }
    
    .neutral { 
      color: var(--primary-orange); 
      font-weight: bold;
    }
    
    .loading { 
      color: #95a5a6; 
      text-align: center; 
      margin: 20px; 
    }
    
    .toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255,255,255,0.7);
      padding: 8px 12px;
      border-radius: 20px;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: var(--primary-green);
    }
    
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    .timeframe-panel {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      margin-top: 25px;
      overflow-x: auto;
      transition: all 0.3s;
    }
    
    .timeframe-panel:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    
    .timeframe-panel h3 {
      text-align: center;
      margin-bottom: 20px;
      color: var(--primary-purple);
      font-size: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    
    .numeric-positive { 
      color: var(--primary-green);
      font-weight: bold;
    }
    
    .numeric-negative { 
      color: var(--primary-red);
      font-weight: bold;
    }
    
    .numeric-neutral { 
      color: var(--primary-orange);
    }
    
    .hp-signal-buy { 
      background-color: var(--light-green);
    }
    
    .hp-signal-sell { 
      background-color: var(--light-red);
    }
    
    .hp-signal-neutral { 
      background-color: var(--light-orange);
    }
    
    .fast-buy { 
      font-weight: bold; 
      color: var(--primary-green);
      background-color: rgba(46, 204, 113, 0.1);
    }
    
    .fast-sell { 
      font-weight: bold; 
      color: var(--primary-red);
      background-color: rgba(231, 76, 60, 0.1);
    }
    
    /* ADX System Styles */
    .trend-very-strong { 
      background: linear-gradient(135deg, rgba(46, 204, 113, 0.15) 0%, rgba(39, 174, 96, 0.15) 100%);
    }
    
    .trend-strong { 
      background: linear-gradient(135deg, rgba(52, 152, 219, 0.15) 0%, rgba(41, 128, 185, 0.15) 100%);
    }
    
    .trend-moderate { 
      background: linear-gradient(135deg, rgba(243, 156, 18, 0.15) 0%, rgba(230, 126, 34, 0.15) 100%);
    }
    
    .trend-weak { 
      background: linear-gradient(135deg, rgba(231, 76, 60, 0.1) 0%, rgba(192, 57, 43, 0.1) 100%);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      
      .search-box input {
        width: 82%;
      }
      
      table {
        font-size: 14px;
      }
      
      th, td {
        padding: 8px 5px;
      }
      
      .panel-container {
        flex-direction: column;
      }
      
      .panel-left, .panel-right {
        width: 100% !important;
      }
    }
    
    /* Animation for loading */
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    
    .loading {
      animation: pulse 1.5s infinite;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--primary-blue);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--dark-blue);
    }
    
    /* Floating action button for manual refresh */
    .fab {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--primary-green);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.3s;
      z-index: 100;
    }
    
    .fab:hover {
      transform: scale(1.1);
      background: var(--dark-green);
    }
    
    /* Panel container for side-by-side layout */
    .panel-container {
      display: flex;
      gap: 20px;
      width: 100%;
    }
    
    .panel-left {
      width: 60%;
    }
    
    .panel-right {
      width: 40%;
    }
  </style>
</head>
<body>
  <h2>Market Trend System</h2>
  
  <div class="controls">
    <div class="search-box">
      <input type="text" id="coinSearch" placeholder="Search coin..." oninput="filterCoins()">
    </div>
    
    <select id="coinSelect">
      <option value="">Loading coins...</option>
    </select>
    
    <button id="loadBtn" onclick="manualRunKalman()">Load Data</button>
    
    <div class="toggle-container">
      <span>Auto-Update:</span>
      <label class="toggle-switch">
        <input type="checkbox" id="autoUpdateToggle" checked>
        <span class="slider"></span>
      </label>
    </div>
    <div class="price-display" id="priceDisplay">Select a coin to see live price</div>
  </div>
  

  <!-- Timeframe Panel -->
  <div class="timeframe-panel">
    <h3>Kalman Trend Sytstem</h3>
    <table id="timeframeSignals">
      <thead>
        <tr>
          <th>Timeframe</th>
          <th>Kalman Trend</th>
          <th>Slope (Speed)</th>
          <th>Reversal</th>
          <th>Confirmation Ratio</th>
          <th>Cross Zone</th>
          <th>Trend Score</th>
          <th>Alignment</th>
          <th>Noise Filter</th>
          <th>Deviation Spike</th>
          <th>Volatility</th>
          <th>Flat Zone</th>
          <th>Breakout</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>5 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>15 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>30 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>1 hour</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>4 hours</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>1 day</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>1 week</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
        <tr><td>1 month</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
      </tbody>
    </table>
  </div>

  <!-- Panel Container for HP Filter and ADX System -->
  <div class="panel-container">
    <!-- HP Filter Panel (Left Side) -->
    <div class="panel-left">
      <div class="timeframe-panel">
        <h3>Trend System of HP Filter</h3>
        <table id="hpFilterSignals">
          <thead>
            <tr>
              <th>Timeframe</th>
              <th>HP Trend</th>
              <th>Slope Speed</th>
              <th>Crossover</th>
              <th>Divergence</th>
              <th>Slope Acceleration</th>
              <th>Multi Timeframe Confirm</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>5 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>15 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>30 min</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 hour</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>4 hours</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 day</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 week</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 month</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td><td class="loading">-</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- ADX System Panel (Right Side) -->
    <div class="panel-right">
      <div class="timeframe-panel">
        <h3>ADX Trend System</h3>
        <table id="adxSignals">
          <thead>
            <tr>
              <th>Timeframe</th>
              <th>ADX/+DI/-DI</th>
              <th>ADX Trend</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>5 min</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>15 min</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>30 min</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 hour</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>4 hours</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 day</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 week</td><td class="loading">-</td><td class="loading">-</td></tr>
            <tr><td>1 month</td><td class="loading">-</td><td class="loading">-</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Floating Action Button -->
  <div class="fab" onclick="manualRunKalman()" title="Refresh Data">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="23 4 23 10 17 10"></polyline>
      <polyline points="1 20 1 14 7 14"></polyline>
      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
    </svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script>
    // Global variables
    let allCoins = [];
    let filteredCoins = [];
    let priceWebSocket = null;
    let currentCoin = '';
    let kalmanInterval = null;
    let isAutoUpdateEnabled = true;
    
    // Initialize the app when DOM loads
    document.addEventListener('DOMContentLoaded', function() {
      loadAllCoins();
      
      // Setup auto-update toggle
      document.getElementById('autoUpdateToggle').addEventListener('change', function() {
        isAutoUpdateEnabled = this.checked;
        if (isAutoUpdateEnabled) {
          startAutoUpdate();
        } else {
          stopAutoUpdate();
        }
      });
      
      // Start with auto-update enabled
      startAutoUpdate();
    });
    
    function startAutoUpdate() {
      stopAutoUpdate(); // Clear any existing interval
      kalmanInterval = setInterval(() => {
        if (currentCoin && isAutoUpdateEnabled) {
          updateTimeframePanel(false); // Update the timeframe panel silently
          updateHPFilterPanel(false); // Update the HP Filter panel silently
          updateADXPanel(false); // Update the ADX panel silently
        }
      }, 5000); // 5 seconds
    }
    
    function stopAutoUpdate() {
      if (kalmanInterval) {
        clearInterval(kalmanInterval);
        kalmanInterval = null;
      }
    }
    
    // Filter coins based on search input
    function filterCoins() {
      const searchTerm = document.getElementById('coinSearch').value.toUpperCase();
      const select = document.getElementById('coinSelect');
      
      if (!searchTerm) {
        select.innerHTML = '<option value="">Select a coin</option>' + 
          allCoins.map(coin => `<option value="${coin}">${coin}</option>`).join('');
        return;
      }
      
      const filtered = allCoins.filter(coin => coin.includes(searchTerm));
      select.innerHTML = '<option value="">Select a coin</option>' + 
        filtered.map(coin => `<option value="${coin}">${coin}</option>`).join('');
    }
    
    // Load all USDT perpetual coins from Binance
    async function loadAllCoins() {
      try {
        document.getElementById('coinSelect').innerHTML = '<option value="">Loading coins...</option>';
        
        const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
        const data = await response.json();
        allCoins = data.symbols
          .filter(s => s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL')
          .map(s => s.symbol)
          .sort();
        
        const select = document.getElementById('coinSelect');
        select.innerHTML = '<option value="">Select a coin</option>';
        allCoins.forEach(coin => {
          select.innerHTML += `<option value="${coin}">${coin}</option>`;
        });
        
        // When coin selection changes, update live price
        select.addEventListener('change', function() {
          currentCoin = this.value;
          if (currentCoin) {
            setupPriceWebSocket(currentCoin);
            if (isAutoUpdateEnabled) {
              updateTimeframePanel();
              updateHPFilterPanel();
              updateADXPanel();
            }
          } else {
            document.getElementById('priceDisplay').textContent = 'Select a coin to see live price';
          }
        });
      } catch (error) {
        console.error('Error loading coins:', error);
        document.getElementById('coinSelect').innerHTML = '<option value="">Error loading coins</option>';
      }
    }
    
    // Setup WebSocket for live price updates
    function setupPriceWebSocket(symbol) {
      // Close previous connection if exists
      if (priceWebSocket) {
        priceWebSocket.close();
      }
      
      const ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@ticker`);
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        const price = parseFloat(data.c).toFixed(4);
        const change = parseFloat(data.P).toFixed(2);
        const color = change >= 0 ? 'var(--primary-green)' : 'var(--primary-red)';
        document.getElementById('priceDisplay').innerHTML = 
          `${symbol} Price: $${price} <span style="color:${color}">(${change}%)</span>`;
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        document.getElementById('priceDisplay').textContent = `${symbol} Price: Connection error`;
      };
      
      priceWebSocket = ws;
    }
    
    class KalmanFilter {
      constructor({ R = 0.01, Q = 0.001, A = 1, B = 0, C = 1 } = {}) {
        this.R = R; this.Q = Q; this.A = A; this.B = B; this.C = C;
        this.cov = NaN; this.x = NaN;
      }
      filter(z, u = 0) {
        if (isNaN(this.x)) {
          this.x = (1 / this.C) * z;
          this.cov = (1 / this.C) * this.R * (1 / this.C);
        } else {
          const predX = this.A * this.x + this.B * u;
          const predCov = this.A * this.cov * this.A + this.Q;
          const K = predCov * this.C / (this.C * predCov * this.C + this.R);
          this.x = predX + K * (z - this.C * predX);
          this.cov = (1 - K * this.C) * predCov;
        }
        return this.x;
      }
      filterSeries(series) {
        return series.map(z => this.filter(z));
      }
    }

    function manualRunKalman() {
      updateTimeframePanel(true); // Force update with loading states
      updateHPFilterPanel(true); // Force update HP Filter panel with loading states
      updateADXPanel(true); // Force update ADX panel with loading states
    }

    // Enhanced function to update the timeframe panel with all requested features
    async function updateTimeframePanel(showLoading = true) {
      const symbol = document.getElementById('coinSelect').value;
      if (!symbol) return;
      
      const timeframes = ['5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M'];
      const tableBody = document.querySelector('#timeframeSignals tbody');
      
      if (showLoading) {
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
          </tr>`
        ).join('');
      }
      
      try {
        // Process each timeframe in parallel
        const results = await Promise.all(timeframes.map(async tf => {
          try {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=14`);
            if (!res.ok) throw new Error(`API error: ${res.status}`);
            
            const data = await res.json();
            const closes = data.map(d => parseFloat(d[4]));
            const kf = new KalmanFilter();
            const filtered = kf.filterSeries(closes);
            const prices = filtered.slice(-3);

            const slope = prices[2] - prices[0];
            const trend = slope > 0.5 ? "Bullish" : slope < -0.5 ? "Bearish" : "Neutral";
            const range = Math.max(...prices) - Math.min(...prices);
            const aligned = prices[2] > prices[1] && prices[1] > prices[0];
            const reversal = (prices[0] < prices[1] && prices[1] > prices[2]) || (prices[0] > prices[1] && prices[1] < prices[2]);
            const breakout = Math.abs(prices[2] - prices[0]) > 3;
            const noise = Math.abs(prices[2] - prices[1]) > 2 && Math.abs(prices[1] - prices[0]) > 2;
            const mean = prices.reduce((a, b) => a + b) / prices.length;
            const deviation = Math.abs(prices[2] - mean) > 3;
            const trendStrength = Math.min(Math.abs(slope) * 20, 100).toFixed(2) + "%";
            const changes = [prices[1] - prices[0], prices[2] - prices[1]];
            const std = Math.sqrt(changes.map(x => x * x).reduce((a, b) => a + b) / changes.length);
            const volatility = std.toFixed(2);
            const confirmRatio = ((prices[2] > prices[1]) + (prices[1] > prices[0])) / 2 * 100 + "%";
            const crossZone = (prices[0] < prices[1] && prices[2] > prices[1]) || (prices[0] > prices[1] && prices[2] < prices[1]);
            
            return { 
              tf, 
              trend, 
              slope: slope.toFixed(2),
              trendStrength,
              confirmRatio,
              aligned: aligned ? "Yes" : "No",
              flatZone: range < 1 ? "Yes" : "No",
              breakout: breakout ? "Yes" : "No",
              noise: noise ? "High" : "Low",
              deviation: deviation ? "Yes" : "No",
              volatility,
              crossZone: crossZone ? "Yes" : "No",
              reversal: reversal ? "Yes" : "No"
            };
          } catch (error) {
            console.error(`Error processing ${tf} timeframe:`, error);
            return { 
              tf, 
              trend: "Error", 
              slope: "Error",
              trendStrength: "Error",
              confirmRatio: "Error",
              aligned: "Error",
              flatZone: "Error",
              breakout: "Error",
              noise: "Error",
              deviation: "Error",
              volatility: "Error",
              crossZone: "Error",
              reversal: "Error"
            };
          }
        }));
        
        // Update the table with all results at once
        tableBody.innerHTML = results.map(result => {
          const trendClass = result.trend.toLowerCase();
          const slopeClass = result.slope === "Error" ? "" : 
                           parseFloat(result.slope) > 0 ? "numeric-positive" : 
                           parseFloat(result.slope) < 0 ? "numeric-negative" : "numeric-neutral";
          
          return `
            <tr>
              <td>${result.tf}</td>
              <td class="${trendClass}">${result.trend}</td>
              <td class="${slopeClass}">${result.slope}</td>
              <td>${result.reversal}</td>
              <td>${result.confirmRatio}</td>
              <td>${result.crossZone}</td>
              <td>${result.trendStrength}</td>
              <td>${result.aligned}</td>
              <td>${result.noise}</td>
              <td>${result.deviation}</td>
              <td>${result.volatility}</td>
              <td>${result.flatZone}</td>
              <td>${result.breakout}</td>
            </tr>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Error updating timeframe panel:', error);
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
          </tr>`
        ).join('');
      }
    }

    // HP Filter functions
    // Create second difference matrix D of size (n-2) x n
    function createDMatrix(n) {
      let D = math.zeros(n-2, n);
      for(let i=0; i<n-2; i++) {
        D.subset(math.index(i, i), 1);
        D.subset(math.index(i, i+1), -2);
        D.subset(math.index(i, i+2), 1);
      }
      return D;
    }

    // HP Filter matrix solve
    function hpFilterAdvanced(y, lambda) {
      const n = y.length;
      const I = math.identity(n);
      const D = createDMatrix(n);
      const Dt = math.transpose(D);
      // A = I + lambda * Dt * D
      let A = math.add(I, math.multiply(lambda, math.multiply(Dt, D)));
      // Solve A * tau = y for tau
      // y vector as column matrix
      const yVec = math.matrix(y);
      const tau = math.lusolve(A, yVec);
      // Convert tau to simple array
      return tau.valueOf().map(v => v[0]);
    }

    // Calculate signals based on HP trend and price
    function calculateHPSignals(priceData, trendData) {
      const n = priceData.length;
      const last = n-1;

      // 1. Trend Direction
      let trendDirection = (trendData[last] > trendData[last-1]) ? 'Uptrend' : 'Downtrend';

      // 2. Price Crossover
      let priceCrossover = 'Neutral';
      if(priceData[last] > trendData[last] && priceData[last-1] <= trendData[last-1]) priceCrossover = 'Price Above';
      else if(priceData[last] < trendData[last] && priceData[last-1] >= trendData[last-1]) priceCrossover = 'Price Below';

      // 3. Divergence
      let priceChange = priceData[last] - priceData[last-1];
      let trendChange = trendData[last] - trendData[last-1];
      let divergence = 'No Divergence';
      if(priceChange > 0 && trendChange < 0) divergence = 'Bearish Divergence';
      else if(priceChange < 0 && trendChange > 0) divergence = 'Bullish Divergence';

      // 4. Slope Acceleration
      let slopePrev = trendData[last-1] - trendData[last-2];
      let slopeCurr = trendData[last] - trendData[last-1];
      let slopePrev2 = trendData[last-2] - trendData[last-3];
      let accelPrev = slopePrev - slopePrev2;
      let accelCurr = slopeCurr - slopePrev;
      let slopeAccel = 'Stable';
      if(accelPrev < accelCurr) slopeAccel = 'Accelerating';
      else if(accelPrev > accelCurr) slopeAccel = 'Decelerating';

      // 5. Multi-Timeframe Confirm (dummy)
      let multiTF = (trendDirection === 'Uptrend') ? 'Confirmed' : 'Not Confirmed';

      return {
        trendDirection,
        priceCrossover,
        divergence,
        slopeAccel,
        multiTF
      };
    }

    // Update HP Filter panel with real data
    async function updateHPFilterPanel(showLoading = true) {
      const symbol = document.getElementById('coinSelect').value;
      if (!symbol) return;
      
      const timeframes = ['5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M'];
      const tableBody = document.querySelector('#hpFilterSignals tbody');
      
      if (showLoading) {
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
          </tr>`
        ).join('');
      }
      
      try {
        // Process each timeframe in parallel
        const results = await Promise.all(timeframes.map(async tf => {
          try {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=14`);
            if (!res.ok) throw new Error(`API error: ${res.status}`);
            
            const data = await res.json();
            const closes = data.map(d => parseFloat(d[4]));

            // Lambda adjust for timeframe roughly
            let lambda = 1600; // default for daily
            if(tf === '5m' || tf === '15m') lambda = 129600;
            else if(tf === '30m') lambda = 64800;
            else if(tf === '1h') lambda = 23040;
            else if(tf === '4h') lambda = 3600;
            else if(tf === '1w') lambda = 400;
            else if(tf === '1M') lambda = 160;

            // Calculate HP trend using advanced matrix solve
            let trend = hpFilterAdvanced(closes, lambda);

            // Calculate HP Slope Speed (difference between last two trend points)
            const hpSlopeSpeed = (trend[trend.length-1] - trend[trend.length-2]).toFixed(2);

            // Calculate signals
            let signals = calculateHPSignals(closes, trend);

            return { 
              tf, 
              trendDirection: signals.trendDirection,
              priceCrossover: signals.priceCrossover,
              divergence: signals.divergence,
              slopeAccel: signals.slopeAccel,
              multiTF: signals.multiTF,
              hpSlopeSpeed: hpSlopeSpeed
            };
          } catch (error) {
            console.error(`Error processing ${tf} timeframe:`, error);
            return { 
              tf, 
              trendDirection: "Error",
              priceCrossover: "Error",
              divergence: "Error",
              slopeAccel: "Error",
              multiTF: "Error",
              hpSlopeSpeed: "Error"
            };
          }
        }));
        
        // Update the table with all results at once
        tableBody.innerHTML = results.map(result => {
          // Determine row class based on strongest signal
          let rowClass = '';
          if (result.divergence.includes('Bullish')) rowClass = 'hp-signal-buy';
          else if (result.divergence.includes('Bearish')) rowClass = 'hp-signal-sell';
          
          // Determine slope class
          const slopeClass = parseFloat(result.hpSlopeSpeed) > 0 ? 'numeric-positive' : 
                           parseFloat(result.hpSlopeSpeed) < 0 ? 'numeric-negative' : 'numeric-neutral';
          
          return `
            <tr class="${rowClass}">
              <td>${result.tf}</td>
              <td>${result.trendDirection}</td>
              <td class="${slopeClass}">${result.hpSlopeSpeed}</td>
              <td>${result.priceCrossover}</td>
              <td>${result.divergence}</td>
              <td>${result.slopeAccel}</td>
              <td>${result.multiTF}</td>
            </tr>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Error updating HP Filter panel:', error);
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
          </tr>`
        ).join('');
      }
    }
    
    // ADX Calculation
    function calculateADX(candles) {
      const tr=[], plusDM=[], minusDM=[];
      for (let i=1;i<candles.length;i++){
        const prev=candles[i-1], curr=candles[i];
        const up=curr.high-prev.high, down=prev.low-curr.low;
        plusDM.push(up>down && up>0?up:0);
        minusDM.push(down>up && down>0?down:0);
        tr.push(Math.max(curr.high-curr.low, Math.abs(curr.high-prev.close), Math.abs(curr.low-prev.close)));
      }
      const period=14;
      let atr=tr.slice(0,period).reduce((a,b)=>a+b)/period;
      let smPlus=plusDM.slice(0,period).reduce((a,b)=>a+b)/period;
      let smMinus=minusDM.slice(0,period).reduce((a,b)=>a+b)/period;
      const pdi=[(smPlus/atr)*100], mdi=[(smMinus/atr)*100], adx=[];
      for (let i=period;i<tr.length;i++){
        atr=(atr*(period-1)+tr[i])/period;
        smPlus=(smPlus*(period-1)+plusDM[i])/period;
        smMinus=(smMinus*(period-1)+minusDM[i])/period;
        pdi.push((smPlus/atr)*100);
        mdi.push((smMinus/atr)*100);
      }
      for (let i=0;i<pdi.length;i++){
        const dx = Math.abs(pdi[i]-mdi[i])/(pdi[i]+mdi[i])*100;
        if (i<period) adx.push(dx);
        else adx.push((adx[i-1]*(period-1)+dx)/period);
      }
      const pad = candles.length - adx.length;
      return {
        adx: Array(pad).fill(0).concat(adx),
        pdi: Array(pad).fill(0).concat(pdi),
        mdi: Array(pad).fill(0).concat(mdi)
      };
    }
    
    // Determine ADX trend
    function determineADXTrend(adxValue, pdiValue, mdiValue) {
      const dir = pdiValue > mdiValue ? 'Bullish' : 'Bearish';
      let str;
      if (adxValue >= 40) str='Very Strong';
      else if (adxValue >= 25) str='Strong';
      else if (adxValue >= 15) str='Moderate';
      else str='Weak';
      return { dir, str };
    }
    
    // Calculate Trend Strength
    function calculateTrendStrength(adxValue, pdiValue, mdiValue) {
      const isBullish = pdiValue > mdiValue;
      
      // Calculate strength score (0-100)
      let strengthScore = Math.min(100, (adxValue / 25) * 100);
      
      // Determine trend category
      let trendCategory = '';
      let trendClass = '';
      
      if (strengthScore > 80) {
        trendCategory = isBullish ? 'Very Strong Bullish' : 'Very Strong Bearish';
        trendClass = 'trend-very-strong';
      } else if (strengthScore > 60) {
        trendCategory = isBullish ? 'Strong Bullish' : 'Strong Bearish';
        trendClass = 'trend-strong';
      } else if (strengthScore > 40) {
        trendCategory = isBullish ? 'Moderate Bullish' : 'Moderate Bearish';
        trendClass = 'trend-moderate';
      } else {
        trendCategory = isBullish ? 'Weak Bullish' : 'Weak Bearish';
        trendClass = 'trend-weak';
      }
      
      return {
        category: trendCategory,
        class: trendClass,
        score: strengthScore.toFixed(0)
      };
    }
    
    // Update ADX panel with real data
    async function updateADXPanel(showLoading = true) {
      const symbol = document.getElementById('coinSelect').value;
      if (!symbol) return;
      
      const timeframes = ['5m', '15m', '30m', '1h', '4h', '1d', '1w', '1M'];
      const tableBody = document.querySelector('#adxSignals tbody');
      
      if (showLoading) {
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td class="loading">-</td>
            <td class="loading">-</td>
          </tr>`
        ).join('');
      }
      
      try {
        // Process each timeframe in parallel
        const results = await Promise.all(timeframes.map(async tf => {
          try {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=100`);
            if (!res.ok) throw new Error(`API error: ${res.status}`);
            
            const data = await res.json();
            
            // Format candles for ADX calculation
            const candles = data.map(k => ({
              high: parseFloat(k[2]),
              low: parseFloat(k[3]),
              close: parseFloat(k[4])
            }));
            
            // Calculate ADX
            const adxData = calculateADX(candles);
            
            const idx = candles.length - 1;
            const adx = adxData.adx[idx]?.toFixed(2) || '-';
            const pdi = adxData.pdi[idx]?.toFixed(2) || '-';
            const mdi = adxData.mdi[idx]?.toFixed(2) || '-';
            
            // Calculate trend strength
            const trendStrength = calculateTrendStrength(
              parseFloat(adx),
              parseFloat(pdi),
              parseFloat(mdi)
            );
            
            return { 
              tf, 
              adxValues: `ADX: ${adx}<br>+DI: ${pdi}<br>-DI: ${mdi}`,
              trendStrength: `${trendStrength.category}<br>(Score: ${trendStrength.score})`,
              trendClass: trendStrength.class
            };
          } catch (error) {
            console.error(`Error processing ${tf} timeframe:`, error);
            return { 
              tf, 
              adxValues: "Error",
              trendStrength: "Error",
              trendClass: ""
            };
          }
        }));
        
        // Update the table with all results at once
        tableBody.innerHTML = results.map(result => {
          return `
            <tr>
              <td>${result.tf}</td>
              <td>${result.adxValues}</td>
              <td class="${result.trendClass}">${result.trendStrength}</td>
            </tr>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Error updating ADX panel:', error);
        tableBody.innerHTML = timeframes.map(tf => 
          `<tr>
            <td>${tf}</td>
            <td style="color:var(--primary-red)">Error</td>
            <td style="color:var(--primary-red)">Error</td>
          </tr>`
        ).join('');
      }
    }
  </script>
</body>
</html>